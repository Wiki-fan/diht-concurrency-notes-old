<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<h3 id="теорема-бернса-линч">Теорема Бернса-Линч</h3>
<blockquote>
<p>Любой проток взаимного исключения для <code>n</code> потоков, построенный только на атомарных чтениях и записях, использует по крайней мере <code>n</code> ячеек памяти.</p>
</blockquote>
<h4 id="доказательство">Доказательство</h4>
<p>Предположим, есть протокол взаимного исключения:<br />
* взаимное исключение;<br />
* свобода от взаимной блокировки;<br />
* использует меньше <code>n</code> ячеек памяти.</p>
<p>Больше ничего не известно.</p>
<ol style="list-style-type: decimal">
<li><p><em>Докажем для <code>n = 2</code></em>.<br />
Пусть есть два потока <code>A</code>, <code>B</code> и ячейка памяти <code>x</code>. Если <code>B</code> придет, ничего не напишет и пройдет в критическую секцию, то тогда поток <code>A</code> также придет и не узнает, что прошел <code>B</code>, поскольку окажется в аналогичной ситуации. Так что каждый поток что-то пишет в ячейку <code>x</code>. Пусть <code>A</code> хочет записать в ячейку <code>x</code> значение <code>v</code>. Пусть перед тем, как он записывал, планировщик включил <code>B</code>, который пишет в <code>x</code> значение <code>v'</code> и проходит в критическую секцию. Тогда потом включаем <code>A</code>, он записывает <code>v</code> и проходит, так как стер все следы существования потока <code>B</code>.</p></li>
<li><p><em>Докажем для <code>n = 3</code></em>.<br />
Хотим такого: пусть поток <code>A</code> хочет писать <code>v</code> в <code>x</code>, а <code>B</code> -- <code>v'</code> в <code>y</code> (и это их первые записи, а <code>C</code> еще не было). Перед записями остановили потоки. Тогда проходит <code>C</code>, а затем включаем обратно <code>A</code> и <code>B</code> и кто-то из них проходит.<br />
<em>Утверждение</em>: ситуация &quot;поток <code>A</code> хочет писать <code>v</code> в <code>x</code>, а <code>B</code> - <code>v'</code> в <code>y</code> (и это их первые записи, а <code>C</code> еще не было)&quot; всегда возможна. Итак, остановим <code>A</code> перед его записью в <code>x</code>. Поток <code>B</code> обязан что-то записать в <code>y</code>, иначе как в ситуации с <code>n = 2</code>. Но перед записью в <code>y</code> он может записать что-то в <code>x</code>, и тогда <code>C</code> уже поймет, что он там не один!<br />
Так что рассмотрим другой механизм: пусть <code>A</code> делает так: <code>lock</code>, <code>unlock</code> три раза. Тогда по принципу Дирихле в какую-то ячейку была запись дважды. Без потери общности это запись в <code>x</code>. Для определенности пусть записывали сначала в <code>x</code>, потом в <code>y</code>, а потом в <code>x</code>. Значит, останавливаем <code>A</code> перед первой записью в <code>x</code>. Потом <code>B</code> записывает что-то в <code>x</code> и останавливается перед записью в <code>y</code>. Затем <code>A</code> пишет что-то в <code>x</code>, проходит в критическую секцию и, наконец, делает <code>unlock</code>, возвращая мьютекс в исходное состояние. Затем снова <code>lock</code>, <code>unlock</code>, <code>lock</code>. Остановим его снова перед записью в <code>x</code>. Пропускаем <code>C</code> в критическую секцию. Тогда он видит пустые регистры и проходят в критическую секцию. Тепепь будим потоки <code>A</code> и <code>B</code>; они стирают значения в регистрах и не знают о существовании потока <code>C</code>. Теперь по свойству свободы от взаимных блокировок один из них пройдет в критическую секцию, нарушая тем самым взаимное исключение.</p></li>
<li><p><em>Доказательство для произвольного <code>n &gt; 3</code></em>.<br />
Есть потоки <code>T[0]</code>, <code>T[1]</code>, ..., <code>T[n-2]</code> и <code>T[n-1]</code>. Будем действовать, как и раньше. Остановим каждый <code>T[i]</code> при <code>i = 0 ... n - 2</code> перед его первой записью в <code>x[i]</code>. Препдположение индукции: пусть первые <code>k</code> потоков пишут в различные <code>k = 0 ... n - 3</code> ячеек памяти. Докажем, что <code>k + 1</code>-й будет писать в том числе и хотя бы одну запись в другую ячейку памяти. Иначе мы сотрем его результаты, и взаимное исключение нарушится. Будем по индукции запускать потоки. Сначала покрываем 2 ячейки, потом 3 и так далее.</p></li>
</ol>
</body>
</html>
