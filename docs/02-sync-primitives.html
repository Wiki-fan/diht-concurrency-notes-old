<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<h1 id="примитивы-синхронизации-условные-переменные-семафоры-фьютексы">Примитивы синхронизации: условные переменные, семафоры, фьютексы</h1>
<h2 id="мотивация-какую-задачу-мы-хотим-решать">Мотивация: какую задачу мы хотим решать?</h2>
<p>Мы хотим строить очереди. Есть два класса потока: producer / consumer. Одни кладут данные, другие берут. Мьютексы, очевидно, эту задач не решают.<br />
Интерфейс: <code>enq</code>, <code>deq</code>. Отличие в том, что методы блокирующие. Они должны завершиться корректно. Если сейчас места в очереди нет, а надо положить, или извлекаем из пустой, то ждем, пока можно будет правильно выполнить метод.<br />
Очереди в параллельном мире полезны тем, что уравновешивают потоки, работающие с разной скоростью. С их помощью можно реализовать thread pool.</p>
<p>В случае thread pool очередь балансирует нагрузку. Если в очереди есть задачи, то все потоки заняты, если она пуста, значит, задач нет.<br />
Итак, хотим соорудить такую очередь. Как ждать, пока элемент не будет добавлен? Наоборот, как ждать, пока очередь не освободиться?</p>
<h2 id="условные-переменные">Условные переменные</h2>
<p>Это еще один механизм синхронизации. Три метода, решающие три задачи:</p>
<ol style="list-style-type: decimal">
<li>ожидание выполнения какого-то события;</li>
<li>оповестить один спящий поток;</li>
<li>разбудить все спящие потоки.</li>
</ol>
<p>Это как раз то, что нам нужно: <code>cv.wait(mtx)</code> - заснуть в ожидание потока, отпустив мьютекс. С условной переменной всегда работает два потока.</p>
<p>На примере очереди, есть контейнер, мьютекс, предикат <em>очередь не пуста</em> и условная переменная.</p>
<h3 id="интерфейс">Интерфейс</h3>
<p>Поток выполняет <code>wait(mtx)</code>, когда он владеет мьютексом <code>mtx</code>. Поток атомарно отпускает мьютекс и засыпает в ожидании сигнала (методы 2 и 3). Когда сигнал приходит, мьютекс вновь захватывается. Атомарнось важна, потому что иначе другой поток может взять мьютекс, послать сигнал, и только затем наш поток заснет. Но так он пропустит сигнал.</p>
<p><code>notify</code> не блокируется другими потоками. Если сигнал никто не ждал, то он просто потеряется. Ну и ладно. Если же сигнал пришел не тому потоку, у которого был <code>wait</code>, то тоже. Это уже грустно.</p>
<p>Когда поток просыпается, он получает мьютекс обратно. Это значит, что он встает в очередь на захват мьютекса. И когда он его получит, еще неизвестно.</p>
<hr />
<p>Условная переменная связана с предикатом. На уровне кода, однако, синтаксически, между очередью, условной переменной, контейнером и т. п. никакой связи нет.</p>
<h2 id="реализация-очереди">Реализация очереди</h2>
<h3 id="очередь-неограниченного-размера">Очередь неограниченного размера</h3>
<p>Тонкость в том, что <code>wait</code> может вернуть управление: ложное пробуждение (spurious wakeup). Условие может остаться ложным. Но есть еще intercepted (stolen) wakeup: другой поток перехватывает сигнал, предназначенный для другого потока (смотрим слайд).</p>
<p>Вывод: условие проверяем в цикле. Сигнал означает лишь что надо проверить, стало ли верным условие. В языке C++ есть сигнатура <code>cv.wait(mtx, pred)</code>. Она скрывает эту проблему, и цикл можно не писать.</p>
<p>А как же правильно сигналить при добавлении элемента? Может, не нужно сигналить, если добавляем элемент в непустую очередь?</p>
<p><em>Доказательство корректности</em>. Ясно, что благодаря мьютексам можно свести задачу к последовательной. Рисуем пути Дика (только если <code>deq</code> при нуле элементов, стрелку ставим пунктиром вниз, а точку просто вправо). В каждый момент времени есть два типа <code>deq</code>. Одни еще не были вызваны, другие спали. Они не отличаются... ничем! Так что при сигнализировании можно как бы считать, что они перемещаются в очереди. Пусть у нас есть <code>k</code> элементов, а мы делаем <code>k + 1</code>-й <code>enq</code>.</p>
<p>Итак, всегда делаем <code>notify_all</code>. Почему это работает? При переносе спящих в будущее у нас корректная скобочная последовательность, а <code>|enq| - |deq| = k + 1</code>? Индукция по <code>k</code>.</p>
<p>Основные идеи: переносим пунктирные стрелки влево, используем предположение индукции и неравенство на общее количество вызовов <code>|deq| &gt;= |enq|</code>.</p>
<p>Работает <code>notify_all</code>.<br />
Работает также и <code>notify_one</code>.<br />
Даже <code>if item.size() = 1 then notify_all</code> работает.<br />
Но не работает <code>if item.size() = 1 then notify_one</code> - нет! (Сценарий на слайде).</p>
<h3 id="очередь-ограниченного-размера">Очередь ограниченного размера</h3>
<p>Очевидный ход: завести еще одну условную переменную. В домашке напишем и все увидим.</p>
<h2 id="фьютексы">Фьютексы</h2>
<p>Напишем условную переменную сейчас примерно так, как есть в Linux. Для этого понадобится <em>фьютекс</em>.</p>
<p>Заметим, что условные переменные и мьютексы по сути похожи своим паттерном работы, не смотря на разные механизмы и разные исполняемые задачи.</p>
<p>Фьютекс (fast usercpace mutex) - это очередь потоке в ядре, связанные неким образом с ячейкой.</p>
<p>Интерфейс:</p>
<ol style="list-style-type: decimal">
<li><code>futex-wait(addr, value)</code>: если <code>addr != value</code>, засыпить поток;</li>
<li><code>futex-wake(addr)</code>: разбудить поток, связанный с ячейкой <code>addr</code>.</li>
</ol>
<p>Семантика значения в ячейке <code>addr</code> фьютексу неизвестна.</p>
<p>Эти операции в ядре исполнаяются спинлоком, так что между проверкой значения в <code>addr</code> и остановкой потока нельзя сделать <code>futex-wait</code> (типа они блокируются).</p>
<p>Итак, мы хотим написать нормальный мьютекс, то есть мьютекс с Fast Path. Если есть конкуренция (по-научному contention) мы хотим остановиться на время ожидания. А если ее нет, то мы хотим захват сделать быстро, щелкнув атомиком. Так можно избежать прохода в ядро, а это быстрее.</p>
<h3 id="реализация-мьютекса">Реализация мьютекса</h3>
<p>У нас будет счетчик конкурирующих потоков. Если поток увеличивает счетчик с нуля до одного, то он сразу проходит. А если нет, то надо поспать. (См. слайды.)</p>
<h3 id="реализация-условной-переменной">Реализация условной переменной</h3>
<p>Немного сложнее. Считаем число отправленных сигналов. Проблема втом, что нужна атомарность в разблокировки мьютекса. В реализации <code>wait</code> на слайде мы засыпаем только если после анлока счетчик не изменился. Иначе у нас будет упущенный сигнал!</p>
<hr />
<p>Но вообще все это детские шалости. Надо читать статью <em>Futexes are Tricky</em>, где описано, как в Linux мастерили быстрые мьютексы.</p>
<h2 id="семафоры">Семафоры</h2>
<blockquote>
<p>Это лажа. (Р. Липовский)</p>
</blockquote>
<p>Семафор - это блокирующий счетчик и очередь потоков. Многие вещи можно написать и с их помощью.</p>
<p>Интерфейс:</p>
<ol style="list-style-type: decimal">
<li>уменьшить счетчик, если это возможно, или заснуть иначе;</li>
<li>увеличить счетчик.</li>
</ol>
<p>Значения счетчика получить нельзя. Это и ненужно.</p>
<p>Названий методов очень много. Оригинальные <code>P</code> и <code>V</code> придуманы автором - Дейкстрой.</p>
<p>Семафор можно написать на условных переменных. Эту задачу нужно в совершенстве решать на зачете.</p>
</body>
</html>
