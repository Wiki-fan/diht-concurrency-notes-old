<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<h1 id="ликбез-по-операционным-системам">Ликбез по операционным системам</h1>
<h2 id="процесс">Процесс</h2>
<p><strong>Процесс</strong> (process) – это абстракция запущенной программы. Процесс создается в операционной системе после запуска программы.</p>
<h2 id="виртуальная-память">Виртуальная память</h2>
<p>Физическая память может состоять из нескольких модулей, иметь сложную топологию и схему адресации.</p>
<p>Процессы работают с памятью не напрямую, а через слой абстракции – <strong>виртуальную память</strong>.</p>
<p>Виртуальная память с точки зрения программы – это плоская непрерывная память, в которой для адресации достаточно одного целого числа – смещения от начала, т.е. простого индекса.</p>
<p>Диапазон виртуальных адресов называют <strong>виртуальным адресным пространством</strong>.</p>
<p>Задачу отображения виртуальной памяти на физическую берут на себя операционная система и процессор. Программа полностью изолирована от этой машинерии! Она работает с простой плоской моделью памяти и простой схемой адресации.</p>
<p>Размер виртуальной памяти не зависит от доступной физической памяти и определяется только <strong>разрядностью процессора</strong>, т.е. максимальным адресом, который помещается в машинное слово. Для 32-битных процессоров – <strong>4 гигабайта</strong>. Для 64-битных – <strong>16 эксабайт</strong> в теории, на практике для адресации используется меньшее число бит (42/48).</p>
<p>Механизм виртуальной памяти обеспечивает изоляцию процессов в операционной системе: Код одного процесса не может изменять данные в памяти другого процесса, поскольку каждый из процессов работает со своей независимой виртуальной памятью. Виртуальная память – как песочница, в которой копается процесс.</p>
<h2 id="сегменты-памяти">Сегменты памяти</h2>
<p>Виртуальное адресное пространство разделено на логические сегменты: код, данные, стеки, хип и т.п.</p>
<ul>
<li>В сегменте кода находятся скомпилированный код программы, т.е. машинные инструкции, которые будет исполнять процессор.</li>
<li>В сегменте стека – стеки всех потоков программы.</li>
<li>В хипе находятся данные, которые потоки производят во время работы программы. Память в хипе программа получает от аллокатора.</li>
</ul>
<p>Ниже представлена структура памяти процесса для x86.</p>
<p><img src="images/00-1-process-memory.png" style="width:50.0%" /></p>
<h2 id="сегменты-памяти-1">Сегменты памяти</h2>
<p>На разные сегменты настроены разные права доступа: потоки не могут писать в сегмент кода, зато могут писать в сегмент хипа или стеков. Потоки коммуницируют через память <strong>стеков</strong> и <strong>хипа (кучи)</strong>. Для этого каждый поток должен иметь указатель/ссылку на общие данные.</p>
<h2 id="виртуальные-и-физические-адреса">Виртуальные и физические адреса</h2>
<p>Программа оперирует только виртуальными адресами.</p>
<p>Например, на стеке хранится указатель на голову списка, т.е. виртуальный адрес динамической памяти, по этому адресу в динамической памяти находится блок с данными и виртуальный адрес следующего узла списка. Программа не заботится о том, как эти блоки в действительности распределены по микросхемам памяти. Процессор при выполнении инструкций должен транслировать эти виртуальные адреса в физические.</p>
<p>Виртуальное адресное пространство нарезано на блоки фиксированного размера – <strong>страницы памяти</strong>. Виртуальная память отображается на физическую <strong>постранично</strong>: странице виртуального адресного пространства соответствует страница физической памяти. Непрерывный диапазон страниц в виртуальном адресном пространстве не означает, что соответствующая физическая память тоже выделена непрерывным блоком.</p>
<p>Физические страницы выделяются по требованию: Во время первого обращения к виртуальной странице происходит прерывание <strong>page fault</strong>, процессор переключается на операционную систему, и та выделяет физическую страницу. Если page fault возник при чтении из сегмента кода, то операционная система загружает в выделенную физическую страницу код программы с диска.</p>
<h2 id="трансляция-виртуальных-адресов">Трансляция виртуальных адресов</h2>
<p>У каждого процесса есть поисковый индекс, который хранит отображение страниц виртуального адресного пространства в физические адреса – <strong>таблицы страниц</strong>.</p>
<div class="figure">
<img src="images/00-2-virtual-addresses-translation.jpg" style="width:50.0%" />

</div>
<p>Таблица страниц располагается в оперативной памяти. Обращаться к ней напрямую – слишком медленно для процессора. Поэтому в процессоре реализован кэш для трансляции адресов горячих страниц памяти: <strong>TLB</strong> (<em>translation lookaside buffer</em>).</p>
<h2 id="поток-исполнения">Поток исполнения</h2>
<p><strong>Поток исполнения</strong> (<em>thread of execution</em>) – это последовательность инструкций, которую исполняет процессор. Потоки живут в контексте одного процесса и работают с общей виртуальной памятью через сегменты хипа и стека. <strong>Синонимы:</strong> поток, тред, нить.</p>
<p>Для исполняемого потока процессор хранит в служебных регистрах специальные адреса: * instruction pointer (IP) или program counter (PC) – адрес инструкции в сегменте кода, которую нужно исполнить следующей. *stack pointer и frame pointer – указатель на вершину стека и на точку отсчета последнего стекового фрейма текущего потока в сегменте стека.</p>
<h2 id="стековый-фрейм-на-x86">Стековый фрейм на x86</h2>
<div class="figure">
<img src="images/00-3-stack-frame.png" style="width:50.0%" />

</div>
<h2 id="планирование-потоков">Планирование потоков</h2>
<p>Несколько потоков могут исполняться на одном процессоре с помощью механизма разделения времени (time sharing ): Планировщик выдает каждому потоку небольшой промежуток времени на исполнение – квант времени (quantum или time slice).</p>
<p>После того, как квант времени истекает, планировщик либо дает потоку еще один квант (если нет потоков, ждущих в очереди на исполнение), либо останавливает текущий поток, помещает его в очередь на исполнение и выбирает новый поток для исполнения.</p>
<div class="figure">
<img src="images/00-4-thread-planning.jpg" style="width:50.0%" />

</div>
<h2 id="реализация">Реализация</h2>
<p>Системный таймер с фиксированной частотой посылает процессору сигнал – <strong>прерывание</strong> (<em>interrupt</em>).</p>
<p>Получив прерывание от системного таймера, процессор останавливает выполнение текущего потока и исполняет системный код, в котором и вызывается планировщик.</p>
<p>Планировщик увеличивает счетчик тиков текущего потока. Если этот счетчик превысил квант времени, выданный текущему потоку на исполнение, то планировщик снимает его с процессора и запускает новый поток из числа ожидающих исполнения.</p>
<div class="figure">
<img src="images/00-5-time-exceeded-switch.jpg" alt="Переключение по кванту времени" style="width:50.0%" />
<p class="caption">Переключение по кванту времени</p>
</div>
<h2 id="причины-переключений">Причины переключений</h2>
<ul>
<li>Истек квант времени, выделенный потоку на исполнение.</li>
<li>Поток заблокирован системным механизмом синхронизации, например, в момент захвата системного мьютекса.</li>
<li>Поток выполняет блокирующий системный вызов, например, читает данные из сетевого соединения или с диска.</li>
<li>Поток сам готов уступить процессор для исполнения другому потоку с помощью вызова sleep или yield.</li>
</ul>
<h2 id="виды-переключений">Виды переключений</h2>
<ul>
<li>Принудительное: переключение по истечению кванта времени. Поток готов продолжать работу, но прерывается планировщиком.</li>
<li>Добровольное: переключение во время блокирующих системных вызовов. Потоку нужно дождаться некоторого события (освобождения мьютекса, завершения чтения с диска), и на время ожидания он готов уступить процессор потоку, который стоит в очереди на исполнение.</li>
</ul>
<h2 id="context-switch">Context switch</h2>
<p>При переключении нужно сохранить состояние текущего потока (instruction pointer, stack pointer и другие регистры процессора) и симметрично восстановить состояние нового потока. В случае переключения на поток другого процесса нужно переключить виртуальное адресное пространство: сменить таблицы страниц и сбросить кэш трансляции.</p>
<h2 id="переключение-потоков">Переключение потоков</h2>
<p>Переключение процессора с потока на поток сводит на нет различные низкоуровневые процессорные оптимизации:</p>
<ul>
<li>Сбрасывается конвейер процессора, который параллелит разные этапы выполнения инструкций.</li>
<li>Сбрасывается кэш трансляции виртуальных страниц.</li>
<li>Протухает содержимое локальных кэшей процессора, в которых хранились горячие данные, которые использовал поток</li>
</ul>
<p>Мораль: переключение потока – дорогая операция!</p>
<p>Планировщик работает реактивно – перепланирование происходит как реакция на системные вызовы и тики системного таймера.</p>
<h2 id="переключения-с-точки-зрения-потока">Переключения с точки зрения потока</h2>
<p>Поток не может предсказать момент следующего своего переключения, переключение может произойти после каждой машинной инструкции. Поток не может даже наблюдать собственные переключения. Непредсказуемые переключения – главная сложность многопоточного программирования. Логика исполнения программы становится сильно нелинейной, с ростом потоков число вариантов исполнения экспоненциально возрастает.</p>
<h2 id="главное-про-планирование-потоков">Главное про планирование потоков</h2>
<ul>
<li><p><strong>Планировщик</strong> распределяет потоки по процессорам и переключает их.</p></li>
<li>Каждому потоку на исполнение дается небольшой квант времени, после чего планировщик может переключить его на другой поток.</li>
<li>Переключение потоков происходит через ядро.</li>
<li><p>Моменты переключения потоков непредсказуемы, переключение может случиться после каждой инструкции.</p></li>
</ul>
</body>
</html>
