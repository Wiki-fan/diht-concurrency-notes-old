## Задача взаимного исключения

Задача: реализовать в общей памяти _**мьютекс**_ - конкурентный объект `M` с двумя логическими состояниями: _свободен_ (начальное состояние) и _захвачен_ (каким-то из потоков) и двумя операциями:
* `M.lock()` - _захватить_ мьютекс в единоличное владение. 

Если вызов `M.lock()` вернул управление, то это означает, что поток захватил владение мьютексом. 

* `M.unlock()` - _освободить_ (_отпустить_) мьютекс. 

Участок программы между парными вызовами `M.lock()` и `M.unlock()` называется **_критической секцией_** - в таком участке может находиться только один поток программы. Критические секции одного и того же мьютекса не пересекаются во времени.

Если все обращения к объекту `O` (например, к хэш-таблице или списку) выполняются внутри критических секций для одного и того же мьютекса `M`, то говорят, что мьютекс `M` _**защищает**_ объект `O`.

Будем предполагать, что поток находится внутри критической секции конечное время. 


Требования, которым должен удовлетворять протокол взаимного исключения:

* _**Взаимное исключение**_ (_mutual exclusion_): в каждый момент времени в критической секции, т.е. между вызовами `M.lock()` и `M.unlock()`, может находиться не более одного потока.

* _**Свобода от взаимной блокировки**_ (_deadlock freedom_): если несколько потоков пытаются захватить владение мьютексом и войти в критическую секцию, то рано или поздно одному из потоков это удастся. Иначе говоря, если несколько потоков находятся внутри вызова `M.lock()`, то рано или поздно один из вызовов вернет управление.

Взаимное исключение - это _safety property_, оно означает, что ничего плохого не случается, свобода от взаимных блокировок - _liveness property_, оно означает, что рано или поздно случается хорошее.

Заметим, что свобода от взаимной блокировки не означает, что поток, претендующий на владение мьютексом, непременно получит его. Возможна ситуация, когда невезучий поток бесконечно долго кружится в вызове `lock()`, но ввиду особенности протокола и прихоти планировщика постоянно пропускает вперед другие потоки, которые непрерывно заходят в критическую секцию.

Поэтому можно сформулировать более сильную гарантию прогресса:

* _**Свобода от голодания**_ (_starvation freedom_) - каждый поток, претендующий на захват мьютекса, рано или поздно получит его, т.е. каждый вызов `M.lock()` завершается.


Свобода от взаимной блокировки и свобода от голодания - две гарантии прогресса:

Свобода от взаимной блокировки гарантирует прогресс только на уровне всей системы (какой-то из потоков войдет в критическую секцию), в то время свобода от голодания гарантирует прогресс каждого потока (каждый из потоков войдет в критическую секцию).

## Модель исполнения

Все потоки работают в рамках одного адресного пространства и общаются друг с другом только с помощью чтений и записей в общие ячейки памяти.

Предполагаем, что память **атомарна**: наблюдаем глобальный порядок всех чтений и записей, который согласован с порядком операций каждого потока.

Атомарность позволяет моделировать параллельное исполнения программы в многопроцессорной системе с помощью **модели чередования** потоков на **единственном процессоре**.

Ячейки памяти в такой модели называют _атомарными регистрами_.

В модели чередования главная сложность – не физическая параллельность исполнения, а **переключения** потоков. Планировщик операционной системы может переключить поток перед любой операцией, алгоритм должен быть готов к таким поворотам судьбы.

В первом приближении такая модель реализуется в C++11 при использовании _атомарных переменных_ (или просто _атомиков_): каждый атомарный регистр - это экземпляр класса `std::atomic<T>`, запись значения в атомик: `x.store(value)`, чтение - `x.load()`. 

## Алгоритм Петерсона

Сначала научимся решать задачу для частного случая, когда на владение мьютексом претендуют только два потока. Для простоты будем предполагать, что их индексы - 0 и 1 и явно передаются в методы `lock` и `unlock`.

Алгоритм Петерсона был придуман в 1981 году. Он не является первым алгоритмом взаимного исключения (алгоритм Деккера упоминается в статье Дейкстры 1965-го года), но совершенно точно является самым простым.

```
def init():
    want[0] = want[1] = false
    victim = 0

def lock(t):
    want[t] = true
    victim = t

    while want[1 - t] and victim == t:
        pass

def unlock(t):
    want[t] = false
```

Реализация на атомиках в C++11:

```cpp
class peterson_mutex {
public:
     peterson_mutex() {
         want[0].store(false);
         want[1].store(false);
         victim.store(0);
     }

     void lock(int t) {
         want[t].store(true);
         victim.store(t);
         while (want[1 - t].load() && victim.load() == t) {
             // wait
         }
     }

     void unlock(int t) {
         want[t].store(false);
     }

private:
    std::array<std::atomic<bool>, 2> want;
    std::atomic<int> victim;
};
```

Алгоритм Петерсона использует флажки `want` для взаимного исключения, а общую переменную `victim` - для установления порядка, в котором потоки пытаются захватить мьютекс: если два потока столкнулись друг с другом в методе `lock()`, то поток, последним записавший `victim`, уступает. Тем самым нарушается симметрия в их поведении.

**У**: _Алгоритм Петерсона гарантирует взаимное исключение._

Предположим противное: потоки `A` и `B` одновременно находятся в критической секции. Для захвата мьютекса каждый из них должен был сделать запись в переменную `victim` и пройти через цикл ожидания. Пусть для определенности последним запись в `victim` сделал поток `B`. Тогда: 

`A: store(want[A], true)` -> 
`A: store(victim, A)` ->
`B: store(victim, B)` ->
`B: load(want[A])` ->
`B: load(victim)`

Получаем, что поток `B` видел и установку `want[A]` и последним записал в `victim` значение `B`, причем по алгоритму других записей в эти переменные не было. Значит поток `B` не мог выйти из цикла ожидания и попасть в критическую секцию. Противоречие с нашим предположением.

**У**: _Алгоритм Петерсона гарантирует свободу от взаимной блокировки._

Тривиально: оба потока не могут бесконечно вращаться в цикле ожидания, т.к. для этого потоки должны видеть противоположные значения `victim`.

**У**: _Алгоритм Петерсона гарантирует свободу от голодания._

Пусть для определенности поток `A` голодает, т.е. бесконечно крутится в цикле ожидания внутри вызова `lock()`, постоянно перечитывая `want[B] == true` и `victim == A`. Если поток бесконечно много раз перечитывает `want[B] == true`, то это означает, что поток `B` снова и снова заходит в критическую секцию, каждый раз опережая поток `A`. Но если поток `A` находится в цикле ожидания, а `B` - в критической секции, то после того, как `B` покинет ее и попробует войти снова, то перезапишет переменную `victim`: `store(victim, B)`. После этого ожидание потока `A` прервется.

Решим теперь задачу взаимного исключения для произвольного (но заранее известного) числа потоков.

## Турнир для `n` потоков

Ранее мы получили протокол взаимного исключения для двух потоков. Используя этот протокол как строительный кубик, можно собрать протокол взаимного исключения для произвольного фиксированного числа потоков. 

Для простоты предположим, что `n` - степень двойки. Построим полное бинарное дерево с `n` листями, в каждый лист посадим по потоку, а во внутренних узлах установим по мьютексу Петерсона. Чтобы войти в критическую секцию, каждый поток должен подняться по этому дереву вверх до корня, захватив мьютекс каждой вершины на своем пути (в том числе и корня). Для того, чтобы освободить мьютекс, поток должен спуститься по дереву обратно из корня в свой лист, отпустив по пути все захваченные им мьютексы. 

Хранить такое дерево можно с помощью линейной развертки как в алгоритме двоичной кучи.

**У**: _Протокол турнирного дерева удовлетворяет свойству взаимного исключения._

Любые два пути от листа к корню обязательно пересекаются, так что если два потока прошли весь турнир и находятся в критической секции, то можно найти узел турнира, который принадлежит сразу двум потокам, найдем первый из них. На входе у него было только два потока (раз он был первым), и оба потока через него прошли, а значит нарушено свойство взаимного исключения для мьютекса Петерсона.

**У**: Турнир из мьютексов Петерсона гарантирует свободу от голоданий.

Докажем по индукции от корня к листу. Очевидно, что поток, который висит на мьютексе корня, голодать не может по свойству мьютекса Петерсона: впереди него только один поток, который рано или поздно выйдет из критической секции и уйдет вниз в свою ветку, а новые потоки из этой ветки обойти наш поток после этого не смогут, т.к. при попытке это сделать новый поток перезапишет `victim` в корневом мьютексе, а значит уступит дорогу. 

Дальше спускаемся вниз по дереву: если поток завис на внутреннем узле, то поток, который опередил его и поднялся выше, спустится обратно в свою ветку по индуктивному предположению, а новые потоки из этой ветки не смогут обойти ждущий поток по той же самой причине, что и в случае с корнем. 


## Алгоритм Лампорта

Турнирное дерево, построенное на основе протокола Петерсона для двух потоков, гарантирует свободу от голоданий: каждый поток, который вызывает `mtx.lock()`, рано или поздно проходит в критическую секцию. 

Но свобода от голоданий - не самая сильная гарантия прогресса, т.к. не гарантирует справедливой очередности: в турнирном дереве поток `A` может медленно ползти вверх в течение долгого времени, но потом вдруг появится поток `B`, который быстро пробежится от своего листа к корню и обгонит поток `A`, хотя пришел значительно позже.

Сформулируем наше требование формально:
 
Разделим метод `lock()` на две секции, которые назовем **_doorway-секцией_** и **_wait-секцией_**  и потребуем, чтобы doorway-секция всегда выполнялась за конечное число шагов, а секции ожидания позволим работать неопределенно долго. Интуиция за этими понятиями простая, пояснить ее можно на примере алгоритма Петерсона: сначала алгоритм заявляет о своем намерении захватить мьютекс, делая для этого несколько записей (установка флага и переменной `victim`), а затем крутится в ожидании. 

_**Честность**_ (_fairness_) протокола взаимного исключения означает, что если поток `A` выполнил свою doorway-секцию до начала выполнения doorway-секции потока `B`, то `A` войдет в критическую секцию раньше `B`.

Как и в алгоритме Петерсона, в алгоритме Лампорта каждый поток сначала объявляет о своем намерении зайти в критическую секцию, устанавливая `want[t] = true`. Как разрулить конфликтные ситуации?

Идея алгоритма Лампорта очень проста: организовать потоки в живую очередь. Каждый поток в очереди имеет на руках номерок (`ticket[i]`), который определяет очередность вхождения потока в критическую секцию. Каждый поток, заходя в метод `lock()`, опрашивает номерки всех остальных потоков и выбирает себе первый свободный номерок.

```
def init():
    for i in from 1 to n:
        want[i] = false
        ticket[i] = 0

def lock(t):
   choose_ticket(t)
   wait_in_queue(t)

def choose_ticket(t):
   want[t] = true
   ticket[t] = max{ticket[1], ..., ticket[n]} + 1

def wait_in_queue(t):
   for i from 1 to n:
        while want[i] and (ticket[i], i) < (ticket[t], t):
            pass

def unlock(t):
   want[t] = false
```

```cpp
class lamport_mutex {
public:
    lamport_mutex(int n) : want(n), ticket(n) {
        init(n);
    }

    void lock(int t) {
        choose_ticket(t);
        wait_in_queue(t);
    }

    void unlock(int t) {
        want[t].store(false);
    }

private:
    // doorway section, finite number of steps
    void choose_ticket(int t) {
        want[t].store(true);;
        int max_ticket = 0;
        for (int i = 0; i < ticket.size(); ++i) {
            max_ticket = std::max(max_ticket, ticket[i].load());
        }
        ticket[t].store(max_ticket + 1);
    }

    // wait section
    void wait_in_queue(int t) {
        for (int i = 0; i < ticket.size(); ++i) {
            while (want[i] && std::make_pair(ticket[i].load(), i) < std::make_pair(ticket[t].load(), t)) { /* wait */ }
        }
    }

    void init(int n) {
        for (size_t i = 0; i < n; ++i) {
            want[i].store(false);
            ticket[i].store(0);
        }
    }

private:
    std::vector<std::atomic<bool>> want;
    std::vector<std::atomic<int>> ticket;
};
```

Нетрудно заметить, что алгоритм допускает, что несколько потоков могут выбрать себе один и тот же номерок если они пришли одновременно. В этом случае конфликт между ними разрешается просто: в случае равенства номерков потоки выстраиваются в соответствии со своими индексами.

Каждый поток дважды обходит все остальные потоки: первый раз при выборе номерка, второй раз - чтобы дождаться, пока каждый поток с меньшим номерком пройдет через критическую секцию.

**Л**: _Пусть поток `A` прошел через `B` в цикле ожидания, т.е. выполнилось одно из условий `want[B] == false` или `(ticket[A], A) < (ticket[B], B)`. Тогда оно будет выполняться до тех пор, пока `A` не выйдет из критической секции._

Если `A` прочел `want[B] == false`, то значит поток `B` находится за пределами функции `lock`. Если он захочет войти в нее, то выберет номерок строго больший, чем `ticket[A]`. Так что условие будет выполняться.

Если `A` прочел `want[B] == true` и при этом `(ticket[A], A) < (ticket[B], B)`, то это может означать, что
* `B` уже выбрал новый номерок, но оказался позади в очереди
* `B` только выбирает новый номерок, а поток `A` видит старый номерок `ticket[B]`. Но номерки каждого потока монотонно возрастают, так что после того, как поток `B` выберет себе номерок, он будет точно больше, чем `ticket[A]`

**У**: _Алгоритм Лампорта гарантирует взаимное исключение._

Предположим, что в критической секции одновременно оказались два потока `A` и `B`. Если `A` в критической секции, то он должен был пройти поток `B` в цикле ожидания, значит по лемме `(ticket[A], A) < (ticket[B], B)`.
Симметричные рассуждения для `B` приводят к `(ticket[B], B) < (ticket[A], A)`. Получили противоречивые выводы.

**У**: _Алгоритм Лампорта гарантирует свободу от взаимной блокировки._

Предположим, что наступила взаимная блокировка - все потоки уже выбрали номерки и вращаются на сравнении номерков и индексов. Номерки и индексы гарантируют отношение полного порядка на потоках, а значит среди ждущих потоков есть поток `t` с наименьшей парой `(ticket[t], t)`, который не может быть заблокирован другим ждущим потоком.

**У**: _Алгоритм Лампорта гарантирует честность._

Пусть поток `A` выбрал номерок раньше, чем поток `B` начал выбирать. В этом случае поток `B` прочитает в `choose_ticket(B)` номерок `ticket[A]`, а значит выбранный им номерок `ticket[B]` будет строго больше. Значит поток `B` в wait-секции сможет пройти через поток `A` только тогда, когда `want[A]` обратится в ноль, т.е. когда поток `A` выйдет из критической секции.

В алгоритме Петерсона разные потоки писали в один и тот же регистр `victim`, с помощью него они определяли, кто подошел последним. В алгоритме Лампорта в каждый регистр пишет только один поток, а определение очередности устроено по принципу логических часов: поток при входе в `lock` спрашивает у всех остальных потоков их временные метки и устанавливает время на своих собственных часах.


## Нижняя оценка на число регистров

Мы рассмотрели два алгоритма взаимного исключения для `n` потоков (Лампорта и турнирного дерева), и каждый из них требовал линейного числа атомарных регистров: у турнирного дерева было `n` внутренних узлов, в каждом по мьютексу Петерсона (3 ячейки памяти на каждый), а в алгоритме Лампорта требовалось хранить флажок и временную метку для каждого из потоков. Можно ли обойтись меньшим количеством ячеек памяти? Ответ дает следующая теорема:

**Т** (Бернса-Линч): _Любой протокол взаимного исключения `n` потоков, реализованный на read/write атомарных регистрах, требует по крайней мере `n` таких регистров._

Начнем с простых соображений:

**Л**: _Для взаимного исключения каждый поток должен сделать запись хотя бы в один регистр._

Каждый поток, который пытается зайти в критическую секцию, должен выполнить хотя бы одну запись в память, т.к. это единственный способ сообщить другим потокам о своем существовании. В противном случае другой поток не увидит никаких следов (т.е. записей в память) и для него исполнение будет не отличимо от исполнения, где первого потока вообще не было, а значит по гарантии прогресса он должен зайти в критическую секцию.

**У**: _Для взаимного исключения двух потоков требуется по крайней мере два атомарных регистра._

Предположим, что нашелся алгоритм, использующий только один атомарный регистр, назовем этот регистр `x`. Будем играть на стороне планировщика и усправлять исполнением потоков. Пусть мьютекс свободен, и поток `A` вызывает `lock()`. По свойству свободы от блокировок рано или поздно вызов `lock()` в потоке `A` должен завершиться, а по предыдущей лемме для этого `A` должен сделать хотя бы одну запись в регистр `x`. Остановим `A` прямо перед этой записью и запустим в потоке `B` метод `lock()`. Будем говорить, что поток `A` **_покрывает_** регистр `x` Для потока `B` мьютекс по-прежнему выглядит свободным: записей в `x` еще не было. Значит по той же гарантии прогресса поток `B` рано завершит свой вызов `lock()` и войдет в критическую секцию. После того, как это произойдет, разбудим поток `A`, и он сразу сделает запись в `x`, тем самым стерев из памяти следы пребывания потока `B`. Теперь узнать о существовании потока `B` он никак не может, конфигурация не отличима от той, в которой потока `B` вообще никогда не было, значит он тоже войдет в критическую секцию.

**У**: _Для взаимного исключения трех потоков нужно по крайней мере три атомарных регистра_.

Будем действовать аналогично: построим такое исполнение, в котором настанет момент, когда мьютекс не захвачен, а потоки `A` и `B` готовы сделать свои первые записи в методах `lock()`, причем `A` будет писать в регистр `x`, а поток `B` - в регистр `y`, т.е. когда `A` и `B` покрывают регистры `x` и `y` соответственно. Тогда мы сможем остановить их, запустить поток `C`, который не увидит никаких следов других потоков (потому что ни одна запись на свободном мьютексе еще не сделана) и по свойству свободы от блокировок зайдет в критическую секцию. После этого разбудим потоки `A` и `B`, они сделают свои записи и сотрут следы существования потока `C`, даже не прочитав их. Для `A` и `B` теперь исполнение не отличимо от исполнения, в котором `C` вообще не существовал, так что по свойству свободы от взаимной блокировки какой-то из потоков `A` и `B` должен зайти в критическую секцию и тем самым нарушить взаимное исключение. 

Вопрос теперь в том, как добиться такой конфигурации, когда `A` и `B` покрывают регистры `x` и `y` своими первыми записями.

Пусть мы заставили поток `A` три раза подряд зайти в критическую секцию. Для каждого из трех вызовов `mtx.lock()` посмотрим, в какой из регистров была сделана первая запись. По принципу Дирехле в двух случаях из трех первая запись была сделана в один и тот же регистр. Для определенности положим, что поток `A` дважды писал сначала в регистр `x`, при первом вызове `lock()` и при третьем, а при втором - сначала в `y`. Другие варианты принципиально отличаться не будут.

Вернемся в прошлое: пусть поток `A` внутри первого вызова `lock()` хочет сделать свою первую запись (в регистр `x`). Остановим его в этот момент и запустим поток `B`. Поток `B` должен сделать по крайней мере одну запись в память, причем если он запишет только в `x`, то поток `A` после пробуждения об этом не узнает, и будет нарушено взаимное исключение. Так что поток `B` должен сделать запись еще и в `y`. Остановим поток `B` как раз перед этой записью. 

Казалось бы, конфигурация найдена: `A` хочет записать в `x`, `B` - в `y`, и можно запустить поток `C`. Но нет, нельзя, поскольку `B` мог что-то записать в `x`, и поток `C`, прочитав `x`, узнает о существовании потока `B`. Поэтому запустим поток `A` и пусть он захватит мьютекс, перезаписав `x`, потом выполнит еще один цикл, в котором перезапишет `y`, а затем в третий раз зайдет уже в свободный мьютекс и захочет снова писать `x`. Записи из предыдущих раундов не должны влиять на решение `C`, так что теперь можно запускать его.


Для `n` потоков идея доказательства такая же: нужно построить исполнение, в котором `n-1` потоков покроют первыми записями каждый из `n-1` регистров, после чего нужно запустить `n`-ый поток, дать ему пройти в критическую секцию, после чего запустить остальные потоки и дать им стереть следы пребывания 'n'-го потока. Исполнение строится индуктивно по числу потоков, шаг индукции реализуется с помощью той же идеи, что и в утверждении для трех потоков.


Заметим, что полученная нижняя оценка никак не зависит от разрядности регистров!

Теорема дает нам интуицию, что атомарные переменные с операциями чтения/записи - это не слишком мощный инструмент, т.к. состояние растет линейно с числом потоков. Этой темы мы коснемся при разговоре о wait-free иеарархии, где формализуем эту интуицию.

По этой причине все современные архитектуры процессоров поддерживают не только атомарные чтения/записи, но и более сложные композитные операции под общим названием RMW.

## Атомарные RMW операции

_**RMW-операция**_ (_read-modify-write_) - это операция над ячейкой памяти, которая атомарно делает несколько шагов: читает значение из этой ячейки (read), (возможно, но не обязательно) модифицирует его (modify), после чего записывает значение обратно в память (write). Атомарность означает, что никакой другой поток не может наблюдать эту операцию в процессе ее исполнения, т.е. между чтением и записью никакой другой поток не может выполнить запись в эту переменную.

## Test-and-set (TAS) spinlock

Простейшая RMW-операция - `test-and-set` или `TAS`. 

Вызов `test-and-set(x, v)` читает и возвращает старое значение переменной `x` и записывает в нее новое значение `v`, причем делает эти шаги атомарно, так что  никакой другой поток не может сделать запись в `x` между чтением и записью в `test-and-set`. Фактически, `test-and-set` делает атомарный `swap` значения в регистре процессора и значения в оперативной памяти.

Семантика `test-and-set(x, value)`:
```
prev-value = read(x)
write(x, value)
return prev-value
```
Три этих шага выполняются атомарно и не могут интерферировать с чтениями/записями из других потоков.

В атомиках операция выглядит так: `T prev = x.exchange(v);`

С помощью этой операции (и обычных атомарных чтений/записей) можно реализовать примитив взаимного исключения для произвольного числа потоков с помощью всего одной атомарной логической переменной! Нижняя оценка повержена!

Псевдокод:
```
def init():
    locked = false

def lock():
    while test-and-set(locked, true):
        pass

def unlock():
    locked = false
```

На атомиках:
```cpp
class spinlock {
public:
    spinlock()
        : locked(false)
    {}
 
    void lock() {
        while (locked.exchange(true)) {
            // wait
        }
    }

    void unlock() {
        locked.store(false);
    }

private:
    std::atomic_bool locked;
};
```

В спинлоке используется единственная атомарная переменная с очевидной семантикой - логический флажок, который взведен, если спинлок захвачен. Захват спинлока устроен следующим образом: поток выполняет `test-and-set(locked, true)`, и если операция возвращает в качестве прочитанного значения `true`, то значит спинлок уже захвачен, так что атомарная перезапись `true` на `true` ничего не изменила. Если же операция вернула `false`, то это означает, что спинлок был свободен, так что атомарно перезаписав `false` на `true` мы стали единоличным его обладателем в силу атомарности операции.

Как видно из реализации, алгоритму не требуются индексы потоков.

Свойства: Алгоритм не гарантирует честности и даже отсутствия голодания: ожидающий поток может вечно крутиться в цикле, пропуская вперед другие потоки, поскольку каждая вызов `test-and-set` в цикле ожидания никак не зависит от предыдущих. Впрочем, на практике такого не происходит.

## Ticket Spinlock

Следующая RMW-операция - `fetch-and-add`. 

Семантика `fetch-and-add(x, a)`:
```
prev-v = read(x)
write(x, prev-v + a)
return prev-v
```

В атомиках операция выглядит так: `T prev = x.fetch_add(v);`

С помощь этой операции (на самом деле достаточно просто атомарного инкремента) и двух атомиков можно реализовать честный протокол взаимного исключения для произвольного числа потоков - ticket spinlock.

Идея такая же, как и в алгоритме Лампорта: потоки, которые хотят войти в критическую секцию, выстраиваются в очередь и ждут, пока потоки впереди них посетят критическую секцию. Но в отличие от алгоритма Лампорта, где потоки сами общались между собой и выбирали себе номерки, в ticket спинлоке используется "автомат" для выдачи последовательных номерков - атомарная переменная с RMW-операций `fetch-and-add` - который гарантирует уникальность и монотонность выдаваемых номерков. 

Алгоритм гарантирует честность, doorway-секцией для ticket спинлока является всего одна строчка - выдача номерка (`next_free_ticket.fetch_add(1)`).

Для того, чтобы понять, что пришла его очередь, каждый поток смотрит на специальное табло - на счетчик `owner_ticket`, в котором записан номерок, обладателю которого разрешается зайти в критическую секцию. Значение этого счетчика увеличивает поток, который покидает критическую секцию, тем самым вызывая поток, который следует за ним в виртуальной очереди.

Псевдокод:
```
def init():
    next-ticket = 0
    owner-ticket = 0

def lock():
    ticket = fetch-and-add(next-ticket, 1)
    while ticket != owner-ticket:
        pass

def unlock():
    owner-ticket = owner-ticket + 1
```

На атомиках:
```cpp
class ticket_spinlock {
private:
    using ticket = std::size_t;
public:
    ticket_spinlock()
        : owner_ticket(0)
        , next_free_ticket(0)
    {}

    void lock() {
        ticket this_thread_ticket = next_free_ticket.fetch_add(1);
        while (owner_ticket.load() != this_thread_ticket) {
            // wait
        }
    }

    void unlock() {
        owner_ticket.store(owner_ticket.load() + 1);
    }
private:
    std::atomic<ticket_t> owner_ticket;
    std::atomic<ticket_t> next_free_ticket;
};
```

Заметим, что в `unlock` инкремент тикета не обязан быть атомарным, т.к. в этом месте не бывает конкуренции между потоками, достаточно сделать `owner_ticket.store(owner_ticket.load() + 1)`

Также заметим, что монотонность номерков в алгоритме не требуется. 
