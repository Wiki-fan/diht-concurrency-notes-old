
### Теорема Бернса-Линч  
> Любой проток взаимного исключения для `n` потоков, построенный только на атомарных чтениях и записях, использует по крайней мере `n` ячеек памяти.  

#### Доказательство  
Предположим, есть протокол взаимного исключения:  
* взаимное исключение;  
* свобода от взаимной блокировки;  
* использует меньше `n` ячеек памяти.  

Больше ничего не известно.  

1. _Докажем для `n = 2`_.  
Пусть есть два потока `A`, `B` и ячейка памяти `x`. Если `B` придет, ничего не напишет и пройдет в критическую секцию, то тогда поток `A` также придет и не узнает, что прошел `B`, поскольку окажется в аналогичной ситуации. Так что каждый поток что-то пишет в ячейку `x`. Пусть `A` хочет записать в ячейку `x` значение `v`. Пусть перед тем, как он записывал, планировщик включил `B`, который пишет в `x` значение `v'` и проходит в критическую секцию. Тогда потом включаем `A`, он записывает `v` и проходит, так как стер все следы существования потока `B`.  

2. _Докажем для `n = 3`_.  
Хотим такого: пусть поток `A` хочет писать `v` в `x`, а `B` -- `v'` в `y` (и это их первые записи, а `C` еще не было). Перед записями остановили потоки. Тогда проходит `C`, а затем включаем обратно `A` и `B` и кто-то из них проходит.  
_Утверждение_: ситуация "поток `A` хочет писать `v` в `x`, а `B` - `v'` в `y` (и это их первые записи, а `C` еще не было)" всегда возможна. Итак, остановим `A` перед его записью в `x`. Поток `B` обязан что-то записать в `y`, иначе как в ситуации с `n = 2`. Но перед записью в `y` он может записать что-то в `x`, и тогда `C` уже поймет, что он там не один!  
Так что рассмотрим другой механизм: пусть `A` делает так: `lock`, `unlock` три раза. Тогда по принципу Дирихле в какую-то ячейку была запись дважды. Без потери общности это запись в `x`. Для определенности пусть записывали сначала в `x`, потом в `y`, а потом в `x`. Значит, останавливаем `A` перед первой записью в `x`. Потом `B` записывает что-то в `x` и останавливается перед записью в `y`. Затем `A` пишет что-то в `x`, проходит в критическую секцию и, наконец, делает `unlock`, возвращая мьютекс в исходное состояние. Затем снова `lock`, `unlock`, `lock`. Остановим его снова перед записью в `x`. Пропускаем `C` в критическую секцию. Тогда он видит пустые регистры и проходят в критическую секцию. Тепепь будим потоки `A` и `B`; они стирают значения в регистрах и не знают о существовании потока `C`. Теперь по свойству свободы от взаимных блокировок один из них пройдет в критическую секцию, нарушая тем самым взаимное исключение.  

3. _Доказательство для произвольного `n > 3`_.  
Есть потоки `T[0]`, `T[1]`, ..., `T[n-2]` и `T[n-1]`. Будем действовать, как и раньше. Остановим каждый `T[i]` при `i = 0 ... n - 2` перед его первой записью в `x[i]`. Препдположение индукции: пусть первые `k` потоков пишут в различные `k = 0 ... n - 3` ячеек памяти. Докажем, что `k + 1`-й будет писать в том числе и хотя бы одну запись в другую ячейку памяти. Иначе мы сотрем его результаты, и взаимное исключение нарушится. Будем по индукции запускать потоки. Сначала покрываем 2 ячейки, потом 3 и так далее.
