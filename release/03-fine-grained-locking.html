<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</head>
<body>
<h1 id="fine-grained-locking">Fine-grained Locking</h1>
<p>Используя мьютексы, уже можно сделать потокобезопасной любую структуры данных: в начале каждого метода ставим <code>lock</code>, а в конце <code>unlock</code>. Но это полное отсутствие парелльности, а производительность только упадет.</p>
<p>Когда мы используем мьютекс в таком виде, мы полностью защищаем структуру данных от ее изменения другими потоками. Попробуем защищать ее не целиком, а по независимым частям. Такой способ блокировки называют <em>мелкогранулярными блокировками</em>.</p>
<h2 id="задача-об-обедающих-философах">Задача об обедающих философах</h2>
<p>О чем следует думать, если много <code>lock</code>'ов.</p>
<p>Есть 5 философов (потоки) которые сидят за круглым столом и едят. Между двумя соседними философами лежит 1 вилка (мьютекс). Чтобы философу поесть, ему нужно взять вилку справа и слева от себя, поесть и положить обе вилки обратно. Как им нужно брать вилки, чтобы все они смогли поесть?</p>
<h3 id="способ-1">Способ 1</h3>
<div class="sourceCode"><pre class="sourceCode c++"><code class="sourceCode cpp">left_fork.lock();
right_fork.lock();</code></pre></div>
<p>Ясно, что этот способ не работает, потому что если возьмут одну левую вилку, то произойдет дедлок и взаимная блокировка.</p>
<h3 id="способ-2">Способ 2</h3>
<div class="sourceCode"><pre class="sourceCode c++"><code class="sourceCode cpp"><span class="cf">while</span> (<span class="co">/*не поел*/) {</span>
<span class="co">  left_fork.lock();</span>
<span class="co">  if (right_fork.try_lock()) {</span>
<span class="co">    // едим</span>
<span class="co">  } else {</span>
<span class="co">    left_fork.unlock();</span>
<span class="co">  }</span>
<span class="co">}</span></code></pre></div>
<p>Здесь нет дедлока, однако есть взаимная блокировка: существует исполнение, в котором ни один из философов так и не сможет поесть. Например, все поочередно берут левую вилку, затем пробуют взять правую, у всех не получилось, так что все отпускают левые вилки, а потом заново их берут и так далее. Такая ситуация, где есть каждый поток имеет какой-то локальный прогресс, но глобальный прогресс отсутствует, называются <em>лайвлоками</em> (livelock).</p>
<h3 id="способ-3">Способ 3</h3>
<p>Предлагается доказать, что взаимных блокировок не будет, если использовать способ 1, однако условиться, что один филосов сначала берет правую вилку, а затем левую (философ-правша). Это одно из возможных решений проблемы.</p>
<h2 id="wait-for-graph">Wait-for Graph</h2>
<p>Рассмотрим вспомогательную конструкцию, Wait For Graph. В нем есть два типа вершин: <code>T_i</code> - потоки, <code>M_j</code> - мьютексы. Ребра зависят от состояния системы следующим образом: если <code>T_i</code> хочет захватить мьютекс <code>M_j</code>, то ребро <code>(T_i, M_j)</code>, если мьютекс <code>M_j</code> захвачен потоком <code>T_i</code>, то ребро <code>(M_j, T_i)</code>. Есле же ничего не происходит или вызывается <code>unlock</code>, то ребра нет.</p>
<p>Оказывается, цикл в таком графе равносилен наличию дедлка. Если мьютекс отслеживает этот граф, то он сам может обнаруживать дедлоки.</p>
<p>Простейшая ситуация приведена на примере.</p>
<table>
<thead>
<tr class="header">
<th><code>T_1</code></th>
<th><code>T_2</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>A.lock()</code></td>
<td>...</td>
</tr>
<tr class="even">
<td>...</td>
<td><code>B.lock()</code></td>
</tr>
<tr class="odd">
<td><code>B.lock()</code></td>
<td>...</td>
</tr>
<tr class="even">
<td>...</td>
<td><code>A.lock()</code></td>
</tr>
</tbody>
</table>
<p>Естественно, это взаимная блокировка, и Wait-for Graph имеет следующий вид.<br />
<!--![Цикл в Wait-for Graph](images/simple-wait-for-graph-cycle.jpg)--></p>
<p>Оказывается, можно избежать дедлоков, если ввести на мьютексах глобальный порядок и захватывать только тот мьютекс, номер которого строго больше, чем номера всех захваченных мьютексов. Действительно, обозначим через <code>L(M_j)</code> номер мьютекса. Предположим, в алгоритме, удовлетворяющем вышеописанному свойству, появился дедлок. Тогда в Wait for Graph'е существует цикл, для определенности <code>T_1 -&gt; M_1 -&gt; T_2 -&gt; M_2 -&gt; ... -&gt; M_k -&gt; T_1</code>. Заметим, что в соответствии с определением ребра вида <code>(T_i, M_i)</code> означают желание захватить мьютекс, а ребра вида <code>(M_i, T_(i+1))</code> принадлежность мьютекса потоку. Положим <code>L(T) = max{L(M) | M -&gt; T}</code> - номер максимального мьютекса, захваченного потоком <code>T</code>. Тогда по описанию алгоритма <code>L(T_1) &lt; L(M_1)</code> (можем хотеть захватить только мьютекс, номер которого больше номеров всех захваченных), а <code>L(M_1) &lt;= L(T_2)</code> по определению числа <code>L</code>. Отсюда <code>L(T_1) &lt; L(T_2)</code>. Тогда, продолжая цепочку неравенств, приходим к противоречию.</p>
<h2 id="hash-table">Hash Table</h2>
<p>Попытаемся реализовать контейнер с мелкогранулярными блокировками.</p>
<h3 id="общие-идеи">Общие идеи</h3>
<p>Hash Table поддерживает три операции: <code>Insert(x)</code>, <code>Remove(x)</code>, <code>Containts(x)</code>. При этом элемент не добавляется, если уже содержится. Элементы хранятся в виде контейнера типа, хранящего <code>m</code> односвязных списков; они называются <em>бакетами</em> (bucket). Чтобы понять, куда следует добавить элемент <code>x</code>, используется <em>хеш-функция</em> <code>h : U -&gt; N</code>, сопоставляющая каждому элементу некоторое натуральное число. Тогда элемент <code>x</code> кладется в бакет <code>h(x) mod m</code>.</p>
<p>Интуиция состоит в том, что с разными бакетами можно работать параллельно, так как они не связываются друг с другом. Идея: пусть каждый мьютек отвечает за какой-то кусок бакетов хеш-таблицы. Здесь мьютексы будем называть <code>локами</code>. Для работы с бакетом нужно взять взять лок, который за него отвечает.</p>
<p>У нас один лок будет отвечать за несколько бакетов, поскольку отношение 1 к 1 добиться сложно. Помним, что есть <code>load_factor := size / m</code>, при превышении которым некотррого порогового значения нужно расширять хеш-таблицу, то есть добавлять новые бакеты (кстати, для <code>size</code> нужен атомик). Но если еще при этом добавлять локи, то будет полный ад.</p>
<h3 id="как-расширять-hash-table">Как расширять Hash Table</h3>
<p>При расширении хеш-таблицы затрагиваются все ее элементы. Исторически сложилось, что расширением занимается тот поток, который переполнил таблицы. Поэтому ему для расширения необходимо получить монопольный доступ ко всей таблицы. В момент переполнения один лок он уже держит, но просто пройтись по оставшимся и захватить их не выходит: возникает простой дедлок при переполнении двумя потоками. Однако если <strong>отпустить свой мьютекс, а потом пройтись по всем из них сначала и захватить</strong>, то дедлоков не будет по тому утверждению, которое мы доказывали с помощью Wait for Graph'а.</p>
<p>Следующая проблема состоит в том, что таблицу могут расширить дважды, ибо другие потоки, переполнившие таблицу, не знают, вдруг она уже расширилась и больше не переполнена. Для решения можно думать, как сравнивать версии таблицы или заново считать <code>load_factor</code>. Однако мы знаем, что если мьютекс взяли, то точно ее никто не мог расширить. Поэтому <strong>после захвата первого мьютекса проверяем актуальное значение <code>load_factor</code>'а и в случае необходимости отказываемся от расширения.</strong></p>
<h4 id="лирическое-отсутпление">Лирическое отсутпление</h4>
<p>Вообще говоря, так все равно плохо, потому что один поток монопольно владеет всей таблицей. Самые быстре хеш-таблицы умеют параллельно переносить данные из одной памяти в другую (параллельные миграции).</p>
<p>Есть аналогия со сборщиком мьютекса. Для них известно два подхода:</p>
<ol style="list-style-type: decimal">
<li><p>сначала маркируем все достижимые состоянии, потом стираем все остальные;</p></li>
<li><p>(копирующий сборщик мусора) маркируем все состояние, достижимые копируем в новое место.</p></li>
</ol>
<p>Есть распараллеленный marking, однако копирование пока что хорошо не получается (хотя что-то там уже придумано); используется метод stop-the-world: тупо останавливается вообще все на свете, и только тогда оно копируется.</p>
<p>Параллельные миграции хеш-таблицы очень похожи на распаллеливание копирования в gargabe collector'е.</p>
<hr />
<p>У нас пока есть еще проблемы. Пусть оракул сказал захватить такой-то лок. Но он занят, а у нас произошло перехеширование, и данный лок теперь защищает другой бакет.</p>
<p>Есть несколько путей решения. Обозначим через <code>n</code> число локов.</p>
<h4 id="способ-1-1">Способ 1</h4>
<p>Локи связаны не с бакетами, а с элементами: <code>L(x) = h(x) mod n</code> - номер соответствующего лока. Но может возникнуть проблема: пусть есть бакет, где лежит элемент <code>x</code>, но в односвязном списке вместе с ним еще есть элемент <code>y</code>, защищаем другим локом. Таким образом, для работы с элементом <code>x</code> нужно брать и другие локи тоже, и вообще все непонятно. Идея не взлетела.</p>
<h4 id="способ-2-1">Способ 2</h4>
<p>Бакеты все же привязаны к локам. Номер бакета считаем по формуле <code>B(x) = h(x) mod m</code>, но число бакетов можем не знать из-за расширения. Идея в том, чтобы сделать дополнительный лок, который блочится в самом начале, из-за чего расширение невозможно. Но тогда через него проходят все потоки, а это уже полное отсутствие параллельности.</p>
<h4 id="способ-3-1">Способ 3</h4>
<p>А если захватывать не особенный лок, а просто какой-то другой рандомный из имеющихся, то можно получить дедлок.</p>
<h4 id="способ-4">Способ 4</h4>
<p>Идея: при перехешировании разрешим бакету может меняться, а страйпу нет. Тогда можно просто перейти в другой бакет, все равно с ним никто не работал.</p>
<p>Например, пусть <code>n = 3</code>, <code>m = 3</code> и лок <code>i</code> защищает бакет <code>i</code>. Расширяем в два раза: появилось три новых бакета. Давайте бакет <code>i</code> будет защищаться локом <code>i mod n</code>.</p>
<p>Формула: <code>B(x) = h(x) mod m</code>, а <code>L(x) = B(x) mod n</code>, откуда <code>L(x) = (h(x) mod m) mod n</code>. Но здесь нужно быть аккуратным: при нудачном расширении номер лока может поменяться. Например, в предыдущем примере если расширять не с 3 до 6, а с 3 до 6, то все станет плохо. <strong>Нужно поддерживать <code>m = kn</code>.</strong> Действительно, тогда <code>L(x) = (h(x) mod kn) mod n = h(x) mod n</code>. А мы это пробовали в начале, но не взлетело, потому что мы не думали тогда о расширениях Теперь же все хорошо; вообще у нас каждый бакет распадается на несколько новых бакетов, защищаемых тем же локом.</p>
<h3 id="readerwriter-mutex">Reader/Writer Mutex</h3>
<blockquote>
<p>Много локов - большая ответственность. (Р. Липовский)</p>
</blockquote>
<p>Вообще мы достигли не очень больших высот, так как при расширении все равно теряется параллельность.</p>
<p>Заметим, что если одновременно использовать <code>Insert</code> и <code>Remove</code>, то все вообще плохо, но несколько одновременных <code>Contains</code> совершенно без проблем существуют вместе.</p>
<p>RW Mutex имеет 2 пары операций: <code>writer_lock</code>, <code>writer_unlock</code>, <code>reader_lock</code>, <code>reader_unlock</code> - и поддерживает инварианты:</p>
<ol style="list-style-type: decimal">
<li>writer-секции не пересекаются ни с какими другими;</li>
<li>reader-секции могут выполняться одновременно.</li>
</ol>
<p>Напишем его дома или на семинаре.</p>
<p>В <code>Insert</code>, <code>Remove</code> и расширении будем вызвать writer-методы, а в <code>Contains</code> - reader.</p>
<h2 id="анонс-будущих-лекций">Анонс будущих лекций</h2>
<p>Мы научимся писать Concurrent Singly-linked Sorted List - многопоточный односвязный отсортированный список Их можно применить к хеш-таблице и использовать как бакеты. Но локи с верхнего уровня убирать не надо, поскольку они все равно нужны для расширения. У нас получится использовать reader-секции везде, кроме расширения.</p>
<p>Отсортированность списка понадобится по двум причинам:</p>
<ol style="list-style-type: decimal">
<li><p>знаем, где находится элемент (с каким ребром в односвязном списке придется работать);</p></li>
<li><p>можно делать клевые <code>lower_bound</code> и т. п.</p></li>
</ol>
<p>Так может получиться <code>set</code>. Почему вообще мы пишем на списках? В STL он на красно-черном дереве. Однако если у нас есть поддерево с большой глубиной, то происходит балансировка (вращение). По-видимому, чтобы делать ее параллельно, нужно блокироваться при работе с узлами. Но как это сделать без дедлоков? Если выбрать какой-то естественный порядок для узлов, то он все равно поменятся на неудачный при балансировке.</p>
</body>
</html>
