<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</head>
<body>
<h2 id="задача-взаимного-исключения">Задача взаимного исключения</h2>
<p>Задача: реализовать в общей памяти <em><strong>мьютекс</strong></em> - конкурентный объект <code>M</code> с двумя логическими состояниями: <em>свободен</em> (начальное состояние) и <em>захвачен</em> (каким-то из потоков) и двумя операциями: * <code>M.lock()</code> - <em>захватить</em> мьютекс в единоличное владение.</p>
<p>Если вызов <code>M.lock()</code> вернул управление, то это означает, что поток захватил владение мьютексом.</p>
<ul>
<li><code>M.unlock()</code> - <em>освободить</em> (<em>отпустить</em>) мьютекс.</li>
</ul>
<p>Участок программы между парными вызовами <code>M.lock()</code> и <code>M.unlock()</code> называется <strong><em>критической секцией</em></strong> - в таком участке может находиться только один поток программы. Критические секции одного и того же мьютекса не пересекаются во времени.</p>
<p>Если все обращения к объекту <code>O</code> (например, к хэш-таблице или списку) выполняются внутри критических секций для одного и того же мьютекса <code>M</code>, то говорят, что мьютекс <code>M</code> <em><strong>защищает</strong></em> объект <code>O</code>.</p>
<p>Будем предполагать, что поток находится внутри критической секции конечное время.</p>
<p>Требования, которым должен удовлетворять протокол взаимного исключения:</p>
<ul>
<li><p><em><strong>Взаимное исключение</strong></em> (<em>mutual exclusion</em>): в каждый момент времени в критической секции, т.е. между вызовами <code>M.lock()</code> и <code>M.unlock()</code>, может находиться не более одного потока.</p></li>
<li><p><em><strong>Свобода от взаимной блокировки</strong></em> (<em>deadlock freedom</em>): если несколько потоков пытаются захватить владение мьютексом и войти в критическую секцию, то рано или поздно одному из потоков это удастся. Иначе говоря, если несколько потоков находятся внутри вызова <code>M.lock()</code>, то рано или поздно один из вызовов вернет управление.</p></li>
</ul>
<p>Взаимное исключение - это <em>safety property</em>, оно означает, что ничего плохого не случается, свобода от взаимных блокировок - <em>liveness property</em>, оно означает, что рано или поздно случается хорошее.</p>
<p>Заметим, что свобода от взаимной блокировки не означает, что поток, претендующий на владение мьютексом, непременно получит его. Возможна ситуация, когда невезучий поток бесконечно долго кружится в вызове <code>lock()</code>, но ввиду особенности протокола и прихоти планировщика постоянно пропускает вперед другие потоки, которые непрерывно заходят в критическую секцию.</p>
<p>Поэтому можно сформулировать более сильную гарантию прогресса:</p>
<ul>
<li><em><strong>Свобода от голодания</strong></em> (<em>starvation freedom</em>) - каждый поток, претендующий на захват мьютекса, рано или поздно получит его, т.е. каждый вызов <code>M.lock()</code> завершается.</li>
</ul>
<p>Свобода от взаимной блокировки и свобода от голодания - две гарантии прогресса:</p>
<p>Свобода от взаимной блокировки гарантирует прогресс только на уровне всей системы (какой-то из потоков войдет в критическую секцию), в то время свобода от голодания гарантирует прогресс каждого потока (каждый из потоков войдет в критическую секцию).</p>
<h2 id="модель-исполнения">Модель исполнения</h2>
<p>Все потоки работают в рамках одного адресного пространства и общаются друг с другом только с помощью чтений и записей в общие ячейки памяти.</p>
<p>Предполагаем, что память <strong>атомарна</strong>: наблюдаем глобальный порядок всех чтений и записей, который согласован с порядком операций каждого потока.</p>
<p>Атомарность позволяет моделировать параллельное исполнения программы в многопроцессорной системе с помощью <strong>модели чередования</strong> потоков на <strong>единственном процессоре</strong>.</p>
<p>Ячейки памяти в такой модели называют <em>атомарными регистрами</em>.</p>
<p>В модели чередования главная сложность – не физическая параллельность исполнения, а <strong>переключения</strong> потоков. Планировщик операционной системы может переключить поток перед любой операцией, алгоритм должен быть готов к таким поворотам судьбы.</p>
<p>В первом приближении такая модель реализуется в C++11 при использовании <em>атомарных переменных</em> (или просто <em>атомиков</em>): каждый атомарный регистр - это экземпляр класса <code>std::atomic&lt;T&gt;</code>, запись значения в атомик: <code>x.store(value)</code>, чтение - <code>x.load()</code>.</p>
<h2 id="алгоритм-петерсона">Алгоритм Петерсона</h2>
<p>Сначала научимся решать задачу для частного случая, когда на владение мьютексом претендуют только два потока. Для простоты будем предполагать, что их индексы - 0 и 1 и явно передаются в методы <code>lock</code> и <code>unlock</code>.</p>
<p>Алгоритм Петерсона был придуман в 1981 году. Он не является первым алгоритмом взаимного исключения (алгоритм Деккера упоминается в статье Дейкстры 1965-го года), но совершенно точно является самым простым.</p>
<pre><code>def init():
    want[0] = want[1] = false
    victim = 0

def lock(t):
    want[t] = true
    victim = t

    while want[1 - t] and victim == t:
        pass

def unlock(t):
    want[t] = false</code></pre>
<p>Реализация на атомиках в C++11:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> peterson_mutex {
<span class="kw">public</span>:
     peterson_mutex() {
         want[<span class="dv">0</span>].store(<span class="kw">false</span>);
         want[<span class="dv">1</span>].store(<span class="kw">false</span>);
         victim.store(<span class="dv">0</span>);
     }

     <span class="dt">void</span> lock(<span class="dt">int</span> t) {
         want[t].store(<span class="kw">true</span>);
         victim.store(t);
         <span class="cf">while</span> (want[<span class="dv">1</span> - t].load() &amp;&amp; victim.load() == t) {
             <span class="co">// wait</span>
         }
     }

     <span class="dt">void</span> unlock(<span class="dt">int</span> t) {
         want[t].store(<span class="kw">false</span>);
     }

<span class="kw">private</span>:
    <span class="bu">std::</span>array&lt;<span class="bu">std::</span>atomic&lt;<span class="dt">bool</span>&gt;, <span class="dv">2</span>&gt; want;
    <span class="bu">std::</span>atomic&lt;<span class="dt">int</span>&gt; victim;
};</code></pre></div>
<p>Алгоритм Петерсона использует флажки <code>want</code> для взаимного исключения, а общую переменную <code>victim</code> - для установления порядка, в котором потоки пытаются захватить мьютекс: если два потока столкнулись друг с другом в методе <code>lock()</code>, то поток, последним записавший <code>victim</code>, уступает. Тем самым нарушается симметрия в их поведении.</p>
<p><strong>У</strong>: <em>Алгоритм Петерсона гарантирует взаимное исключение.</em></p>
<p>Предположим противное: потоки <code>A</code> и <code>B</code> одновременно находятся в критической секции. Для захвата мьютекса каждый из них должен был сделать запись в переменную <code>victim</code> и пройти через цикл ожидания. Пусть для определенности последним запись в <code>victim</code> сделал поток <code>B</code>. Тогда:</p>
<p><code>A: store(want[A], true)</code> -&gt; <code>A: store(victim, A)</code> -&gt; <code>B: store(victim, B)</code> -&gt; <code>B: load(want[A])</code> -&gt; <code>B: load(victim)</code></p>
<p>Получаем, что поток <code>B</code> видел и установку <code>want[A]</code> и последним записал в <code>victim</code> значение <code>B</code>, причем по алгоритму других записей в эти переменные не было. Значит поток <code>B</code> не мог выйти из цикла ожидания и попасть в критическую секцию. Противоречие с нашим предположением.</p>
<p><strong>У</strong>: <em>Алгоритм Петерсона гарантирует свободу от взаимной блокировки.</em></p>
<p>Тривиально: оба потока не могут бесконечно вращаться в цикле ожидания, т.к. для этого потоки должны видеть противоположные значения <code>victim</code>.</p>
<p><strong>У</strong>: <em>Алгоритм Петерсона гарантирует свободу от голодания.</em></p>
<p>Пусть для определенности поток <code>A</code> голодает, т.е. бесконечно крутится в цикле ожидания внутри вызова <code>lock()</code>, постоянно перечитывая <code>want[B] == true</code> и <code>victim == A</code>. Если поток бесконечно много раз перечитывает <code>want[B] == true</code>, то это означает, что поток <code>B</code> снова и снова заходит в критическую секцию, каждый раз опережая поток <code>A</code>. Но если поток <code>A</code> находится в цикле ожидания, а <code>B</code> - в критической секции, то после того, как <code>B</code> покинет ее и попробует войти снова, то перезапишет переменную <code>victim</code>: <code>store(victim, B)</code>. После этого ожидание потока <code>A</code> прервется.</p>
<p>Решим теперь задачу взаимного исключения для произвольного (но заранее известного) числа потоков.</p>
<h2 id="турнир-для-n-потоков">Турнир для <code>n</code> потоков</h2>
<p>Ранее мы получили протокол взаимного исключения для двух потоков. Используя этот протокол как строительный кубик, можно собрать протокол взаимного исключения для произвольного фиксированного числа потоков.</p>
<p>Для простоты предположим, что <code>n</code> - степень двойки. Построим полное бинарное дерево с <code>n</code> листями, в каждый лист посадим по потоку, а во внутренних узлах установим по мьютексу Петерсона. Чтобы войти в критическую секцию, каждый поток должен подняться по этому дереву вверх до корня, захватив мьютекс каждой вершины на своем пути (в том числе и корня). Для того, чтобы освободить мьютекс, поток должен спуститься по дереву обратно из корня в свой лист, отпустив по пути все захваченные им мьютексы.</p>
<p>Хранить такое дерево можно с помощью линейной развертки как в алгоритме двоичной кучи.</p>
<p><strong>У</strong>: <em>Протокол турнирного дерева удовлетворяет свойству взаимного исключения.</em></p>
<p>Любые два пути от листа к корню обязательно пересекаются, так что если два потока прошли весь турнир и находятся в критической секции, то можно найти узел турнира, который принадлежит сразу двум потокам, найдем первый из них. На входе у него было только два потока (раз он был первым), и оба потока через него прошли, а значит нарушено свойство взаимного исключения для мьютекса Петерсона.</p>
<p><strong>У</strong>: Турнир из мьютексов Петерсона гарантирует свободу от голоданий.</p>
<p>Докажем по индукции от корня к листу. Очевидно, что поток, который висит на мьютексе корня, голодать не может по свойству мьютекса Петерсона: впереди него только один поток, который рано или поздно выйдет из критической секции и уйдет вниз в свою ветку, а новые потоки из этой ветки обойти наш поток после этого не смогут, т.к. при попытке это сделать новый поток перезапишет <code>victim</code> в корневом мьютексе, а значит уступит дорогу.</p>
<p>Дальше спускаемся вниз по дереву: если поток завис на внутреннем узле, то поток, который опередил его и поднялся выше, спустится обратно в свою ветку по индуктивному предположению, а новые потоки из этой ветки не смогут обойти ждущий поток по той же самой причине, что и в случае с корнем.</p>
<h2 id="алгоритм-лампорта">Алгоритм Лампорта</h2>
<p>Турнирное дерево, построенное на основе протокола Петерсона для двух потоков, гарантирует свободу от голоданий: каждый поток, который вызывает <code>mtx.lock()</code>, рано или поздно проходит в критическую секцию.</p>
<p>Но свобода от голоданий - не самая сильная гарантия прогресса, т.к. не гарантирует справедливой очередности: в турнирном дереве поток <code>A</code> может медленно ползти вверх в течение долгого времени, но потом вдруг появится поток <code>B</code>, который быстро пробежится от своего листа к корню и обгонит поток <code>A</code>, хотя пришел значительно позже.</p>
<p>Сформулируем наше требование формально:</p>
<p>Разделим метод <code>lock()</code> на две секции, которые назовем <strong><em>doorway-секцией</em></strong> и <strong><em>wait-секцией</em></strong> и потребуем, чтобы doorway-секция всегда выполнялась за конечное число шагов, а секции ожидания позволим работать неопределенно долго. Интуиция за этими понятиями простая, пояснить ее можно на примере алгоритма Петерсона: сначала алгоритм заявляет о своем намерении захватить мьютекс, делая для этого несколько записей (установка флага и переменной <code>victim</code>), а затем крутится в ожидании.</p>
<p><em><strong>Честность</strong></em> (<em>fairness</em>) протокола взаимного исключения означает, что если поток <code>A</code> выполнил свою doorway-секцию до начала выполнения doorway-секции потока <code>B</code>, то <code>A</code> войдет в критическую секцию раньше <code>B</code>.</p>
<p>Как и в алгоритме Петерсона, в алгоритме Лампорта каждый поток сначала объявляет о своем намерении зайти в критическую секцию, устанавливая <code>want[t] = true</code>. Как разрулить конфликтные ситуации?</p>
<p>Идея алгоритма Лампорта очень проста: организовать потоки в живую очередь. Каждый поток в очереди имеет на руках номерок (<code>ticket[i]</code>), который определяет очередность вхождения потока в критическую секцию. Каждый поток, заходя в метод <code>lock()</code>, опрашивает номерки всех остальных потоков и выбирает себе первый свободный номерок.</p>
<pre><code>def init():
    for i in from 1 to n:
        want[i] = false
        ticket[i] = 0

def lock(t):
   choose_ticket(t)
   wait_in_queue(t)

def choose_ticket(t):
   want[t] = true
   ticket[t] = max{ticket[1], ..., ticket[n]} + 1

def wait_in_queue(t):
   for i from 1 to n:
        while want[i] and (ticket[i], i) &lt; (ticket[t], t):
            pass

def unlock(t):
   want[t] = false</code></pre>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> lamport_mutex {
<span class="kw">public</span>:
    lamport_mutex(<span class="dt">int</span> n) : want(n), ticket(n) {
        init(n);
    }

    <span class="dt">void</span> lock(<span class="dt">int</span> t) {
        choose_ticket(t);
        wait_in_queue(t);
    }

    <span class="dt">void</span> unlock(<span class="dt">int</span> t) {
        want[t].store(<span class="kw">false</span>);
    }

<span class="kw">private</span>:
    <span class="co">// doorway section, finite number of steps</span>
    <span class="dt">void</span> choose_ticket(<span class="dt">int</span> t) {
        want[t].store(<span class="kw">true</span>);;
        <span class="dt">int</span> max_ticket = <span class="dv">0</span>;
        <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; ticket.size(); ++i) {
            max_ticket = <span class="bu">std::</span>max(max_ticket, ticket[i].load());
        }
        ticket[t].store(max_ticket + <span class="dv">1</span>);
    }

    <span class="co">// wait section</span>
    <span class="dt">void</span> wait_in_queue(<span class="dt">int</span> t) {
        <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; ticket.size(); ++i) {
            <span class="cf">while</span> (want[i] &amp;&amp; <span class="bu">std::</span>make_pair(ticket[i].load(), i) &lt; <span class="bu">std::</span>make_pair(ticket[t].load(), t)) { <span class="co">/* wait */</span> }
        }
    }

    <span class="dt">void</span> init(<span class="dt">int</span> n) {
        <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
            want[i].store(<span class="kw">false</span>);
            ticket[i].store(<span class="dv">0</span>);
        }
    }

<span class="kw">private</span>:
    <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>atomic&lt;<span class="dt">bool</span>&gt;&gt; want;
    <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>atomic&lt;<span class="dt">int</span>&gt;&gt; ticket;
};</code></pre></div>
<p>Нетрудно заметить, что алгоритм допускает, что несколько потоков могут выбрать себе один и тот же номерок если они пришли одновременно. В этом случае конфликт между ними разрешается просто: в случае равенства номерков потоки выстраиваются в соответствии со своими индексами.</p>
<p>Каждый поток дважды обходит все остальные потоки: первый раз при выборе номерка, второй раз - чтобы дождаться, пока каждый поток с меньшим номерком пройдет через критическую секцию.</p>
<p><strong>Л</strong>: <em>Пусть поток <code>A</code> прошел через <code>B</code> в цикле ожидания, т.е. выполнилось одно из условий <code>want[B] == false</code> или <code>(ticket[A], A) &lt; (ticket[B], B)</code>. Тогда оно будет выполняться до тех пор, пока <code>A</code> не выйдет из критической секции.</em></p>
<p>Если <code>A</code> прочел <code>want[B] == false</code>, то значит поток <code>B</code> находится за пределами функции <code>lock</code>. Если он захочет войти в нее, то выберет номерок строго больший, чем <code>ticket[A]</code>. Так что условие будет выполняться.</p>
<p>Если <code>A</code> прочел <code>want[B] == true</code> и при этом <code>(ticket[A], A) &lt; (ticket[B], B)</code>, то это может означать, что * <code>B</code> уже выбрал новый номерок, но оказался позади в очереди * <code>B</code> только выбирает новый номерок, а поток <code>A</code> видит старый номерок <code>ticket[B]</code>. Но номерки каждого потока монотонно возрастают, так что после того, как поток <code>B</code> выберет себе номерок, он будет точно больше, чем <code>ticket[A]</code></p>
<p><strong>У</strong>: <em>Алгоритм Лампорта гарантирует взаимное исключение.</em></p>
<p>Предположим, что в критической секции одновременно оказались два потока <code>A</code> и <code>B</code>. Если <code>A</code> в критической секции, то он должен был пройти поток <code>B</code> в цикле ожидания, значит по лемме <code>(ticket[A], A) &lt; (ticket[B], B)</code>. Симметричные рассуждения для <code>B</code> приводят к <code>(ticket[B], B) &lt; (ticket[A], A)</code>. Получили противоречивые выводы.</p>
<p><strong>У</strong>: <em>Алгоритм Лампорта гарантирует свободу от взаимной блокировки.</em></p>
<p>Предположим, что наступила взаимная блокировка - все потоки уже выбрали номерки и вращаются на сравнении номерков и индексов. Номерки и индексы гарантируют отношение полного порядка на потоках, а значит среди ждущих потоков есть поток <code>t</code> с наименьшей парой <code>(ticket[t], t)</code>, который не может быть заблокирован другим ждущим потоком.</p>
<p><strong>У</strong>: <em>Алгоритм Лампорта гарантирует честность.</em></p>
<p>Пусть поток <code>A</code> выбрал номерок раньше, чем поток <code>B</code> начал выбирать. В этом случае поток <code>B</code> прочитает в <code>choose_ticket(B)</code> номерок <code>ticket[A]</code>, а значит выбранный им номерок <code>ticket[B]</code> будет строго больше. Значит поток <code>B</code> в wait-секции сможет пройти через поток <code>A</code> только тогда, когда <code>want[A]</code> обратится в ноль, т.е. когда поток <code>A</code> выйдет из критической секции.</p>
<p>В алгоритме Петерсона разные потоки писали в один и тот же регистр <code>victim</code>, с помощью него они определяли, кто подошел последним. В алгоритме Лампорта в каждый регистр пишет только один поток, а определение очередности устроено по принципу логических часов: поток при входе в <code>lock</code> спрашивает у всех остальных потоков их временные метки и устанавливает время на своих собственных часах.</p>
<h2 id="нижняя-оценка-на-число-регистров">Нижняя оценка на число регистров</h2>
<p>Мы рассмотрели два алгоритма взаимного исключения для <code>n</code> потоков (Лампорта и турнирного дерева), и каждый из них требовал линейного числа атомарных регистров: у турнирного дерева было <code>n</code> внутренних узлов, в каждом по мьютексу Петерсона (3 ячейки памяти на каждый), а в алгоритме Лампорта требовалось хранить флажок и временную метку для каждого из потоков. Можно ли обойтись меньшим количеством ячеек памяти? Ответ дает следующая теорема:</p>
<p><strong>Т</strong> (Бернса-Линч): <em>Любой протокол взаимного исключения <code>n</code> потоков, реализованный на read/write атомарных регистрах, требует по крайней мере <code>n</code> таких регистров.</em></p>
<p>Начнем с простых соображений:</p>
<p><strong>Л</strong>: <em>Для взаимного исключения каждый поток должен сделать запись хотя бы в один регистр.</em></p>
<p>Каждый поток, который пытается зайти в критическую секцию, должен выполнить хотя бы одну запись в память, т.к. это единственный способ сообщить другим потокам о своем существовании. В противном случае другой поток не увидит никаких следов (т.е. записей в память) и для него исполнение будет не отличимо от исполнения, где первого потока вообще не было, а значит по гарантии прогресса он должен зайти в критическую секцию.</p>
<p><strong>У</strong>: <em>Для взаимного исключения двух потоков требуется по крайней мере два атомарных регистра.</em></p>
<p>Предположим, что нашелся алгоритм, использующий только один атомарный регистр, назовем этот регистр <code>x</code>. Будем играть на стороне планировщика и усправлять исполнением потоков. Пусть мьютекс свободен, и поток <code>A</code> вызывает <code>lock()</code>. По свойству свободы от блокировок рано или поздно вызов <code>lock()</code> в потоке <code>A</code> должен завершиться, а по предыдущей лемме для этого <code>A</code> должен сделать хотя бы одну запись в регистр <code>x</code>. Остановим <code>A</code> прямо перед этой записью и запустим в потоке <code>B</code> метод <code>lock()</code>. Будем говорить, что поток <code>A</code> <strong><em>покрывает</em></strong> регистр <code>x</code> Для потока <code>B</code> мьютекс по-прежнему выглядит свободным: записей в <code>x</code> еще не было. Значит по той же гарантии прогресса поток <code>B</code> рано завершит свой вызов <code>lock()</code> и войдет в критическую секцию. После того, как это произойдет, разбудим поток <code>A</code>, и он сразу сделает запись в <code>x</code>, тем самым стерев из памяти следы пребывания потока <code>B</code>. Теперь узнать о существовании потока <code>B</code> он никак не может, конфигурация не отличима от той, в которой потока <code>B</code> вообще никогда не было, значит он тоже войдет в критическую секцию.</p>
<p><strong>У</strong>: <em>Для взаимного исключения трех потоков нужно по крайней мере три атомарных регистра</em>.</p>
<p>Будем действовать аналогично: построим такое исполнение, в котором настанет момент, когда мьютекс не захвачен, а потоки <code>A</code> и <code>B</code> готовы сделать свои первые записи в методах <code>lock()</code>, причем <code>A</code> будет писать в регистр <code>x</code>, а поток <code>B</code> - в регистр <code>y</code>, т.е. когда <code>A</code> и <code>B</code> покрывают регистры <code>x</code> и <code>y</code> соответственно. Тогда мы сможем остановить их, запустить поток <code>C</code>, который не увидит никаких следов других потоков (потому что ни одна запись на свободном мьютексе еще не сделана) и по свойству свободы от блокировок зайдет в критическую секцию. После этого разбудим потоки <code>A</code> и <code>B</code>, они сделают свои записи и сотрут следы существования потока <code>C</code>, даже не прочитав их. Для <code>A</code> и <code>B</code> теперь исполнение не отличимо от исполнения, в котором <code>C</code> вообще не существовал, так что по свойству свободы от взаимной блокировки какой-то из потоков <code>A</code> и <code>B</code> должен зайти в критическую секцию и тем самым нарушить взаимное исключение.</p>
<p>Вопрос теперь в том, как добиться такой конфигурации, когда <code>A</code> и <code>B</code> покрывают регистры <code>x</code> и <code>y</code> своими первыми записями.</p>
<p>Пусть мы заставили поток <code>A</code> три раза подряд зайти в критическую секцию. Для каждого из трех вызовов <code>mtx.lock()</code> посмотрим, в какой из регистров была сделана первая запись. По принципу Дирехле в двух случаях из трех первая запись была сделана в один и тот же регистр. Для определенности положим, что поток <code>A</code> дважды писал сначала в регистр <code>x</code>, при первом вызове <code>lock()</code> и при третьем, а при втором - сначала в <code>y</code>. Другие варианты принципиально отличаться не будут.</p>
<p>Вернемся в прошлое: пусть поток <code>A</code> внутри первого вызова <code>lock()</code> хочет сделать свою первую запись (в регистр <code>x</code>). Остановим его в этот момент и запустим поток <code>B</code>. Поток <code>B</code> должен сделать по крайней мере одну запись в память, причем если он запишет только в <code>x</code>, то поток <code>A</code> после пробуждения об этом не узнает, и будет нарушено взаимное исключение. Так что поток <code>B</code> должен сделать запись еще и в <code>y</code>. Остановим поток <code>B</code> как раз перед этой записью.</p>
<p>Казалось бы, конфигурация найдена: <code>A</code> хочет записать в <code>x</code>, <code>B</code> - в <code>y</code>, и можно запустить поток <code>C</code>. Но нет, нельзя, поскольку <code>B</code> мог что-то записать в <code>x</code>, и поток <code>C</code>, прочитав <code>x</code>, узнает о существовании потока <code>B</code>. Поэтому запустим поток <code>A</code> и пусть он захватит мьютекс, перезаписав <code>x</code>, потом выполнит еще один цикл, в котором перезапишет <code>y</code>, а затем в третий раз зайдет уже в свободный мьютекс и захочет снова писать <code>x</code>. Записи из предыдущих раундов не должны влиять на решение <code>C</code>, так что теперь можно запускать его.</p>
<p>Для <code>n</code> потоков идея доказательства такая же: нужно построить исполнение, в котором <code>n-1</code> потоков покроют первыми записями каждый из <code>n-1</code> регистров, после чего нужно запустить <code>n</code>-ый поток, дать ему пройти в критическую секцию, после чего запустить остальные потоки и дать им стереть следы пребывания 'n'-го потока. Исполнение строится индуктивно по числу потоков, шаг индукции реализуется с помощью той же идеи, что и в утверждении для трех потоков.</p>
<p>Заметим, что полученная нижняя оценка никак не зависит от разрядности регистров!</p>
<p>Теорема дает нам интуицию, что атомарные переменные с операциями чтения/записи - это не слишком мощный инструмент, т.к. состояние растет линейно с числом потоков. Этой темы мы коснемся при разговоре о wait-free иеарархии, где формализуем эту интуицию.</p>
<p>По этой причине все современные архитектуры процессоров поддерживают не только атомарные чтения/записи, но и более сложные композитные операции под общим названием RMW.</p>
<h2 id="атомарные-rmw-операции">Атомарные RMW операции</h2>
<p><em><strong>RMW-операция</strong></em> (<em>read-modify-write</em>) - это операция над ячейкой памяти, которая атомарно делает несколько шагов: читает значение из этой ячейки (read), (возможно, но не обязательно) модифицирует его (modify), после чего записывает значение обратно в память (write). Атомарность означает, что никакой другой поток не может наблюдать эту операцию в процессе ее исполнения, т.е. между чтением и записью никакой другой поток не может выполнить запись в эту переменную.</p>
<h2 id="test-and-set-tas-spinlock">Test-and-set (TAS) spinlock</h2>
<p>Простейшая RMW-операция - <code>test-and-set</code> или <code>TAS</code>.</p>
<p>Вызов <code>test-and-set(x, v)</code> читает и возвращает старое значение переменной <code>x</code> и записывает в нее новое значение <code>v</code>, причем делает эти шаги атомарно, так что никакой другой поток не может сделать запись в <code>x</code> между чтением и записью в <code>test-and-set</code>. Фактически, <code>test-and-set</code> делает атомарный <code>swap</code> значения в регистре процессора и значения в оперативной памяти.</p>
<p>Семантика <code>test-and-set(x, value)</code>:</p>
<pre><code>prev-value = read(x)
write(x, value)
return prev-value</code></pre>
<p>Три этих шага выполняются атомарно и не могут интерферировать с чтениями/записями из других потоков.</p>
<p>В атомиках операция выглядит так: <code>T prev = x.exchange(v);</code></p>
<p>С помощью этой операции (и обычных атомарных чтений/записей) можно реализовать примитив взаимного исключения для произвольного числа потоков с помощью всего одной атомарной логической переменной! Нижняя оценка повержена!</p>
<p>Псевдокод:</p>
<pre><code>def init():
    locked = false

def lock():
    while test-and-set(locked, true):
        pass

def unlock():
    locked = false</code></pre>
<p>На атомиках:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> spinlock {
<span class="kw">public</span>:
    spinlock()
        : locked(<span class="kw">false</span>)
    {}
 
    <span class="dt">void</span> lock() {
        <span class="cf">while</span> (locked.exchange(<span class="kw">true</span>)) {
            <span class="co">// wait</span>
        }
    }

    <span class="dt">void</span> unlock() {
        locked.store(<span class="kw">false</span>);
    }

<span class="kw">private</span>:
    <span class="bu">std::</span>atomic_bool locked;
};</code></pre></div>
<p>В спинлоке используется единственная атомарная переменная с очевидной семантикой - логический флажок, который взведен, если спинлок захвачен. Захват спинлока устроен следующим образом: поток выполняет <code>test-and-set(locked, true)</code>, и если операция возвращает в качестве прочитанного значения <code>true</code>, то значит спинлок уже захвачен, так что атомарная перезапись <code>true</code> на <code>true</code> ничего не изменила. Если же операция вернула <code>false</code>, то это означает, что спинлок был свободен, так что атомарно перезаписав <code>false</code> на <code>true</code> мы стали единоличным его обладателем в силу атомарности операции.</p>
<p>Как видно из реализации, алгоритму не требуются индексы потоков.</p>
<p>Свойства: Алгоритм не гарантирует честности и даже отсутствия голодания: ожидающий поток может вечно крутиться в цикле, пропуская вперед другие потоки, поскольку каждая вызов <code>test-and-set</code> в цикле ожидания никак не зависит от предыдущих. Впрочем, на практике такого не происходит.</p>
<h2 id="ticket-spinlock">Ticket Spinlock</h2>
<p>Следующая RMW-операция - <code>fetch-and-add</code>.</p>
<p>Семантика <code>fetch-and-add(x, a)</code>:</p>
<pre><code>prev-v = read(x)
write(x, prev-v + a)
return prev-v</code></pre>
<p>В атомиках операция выглядит так: <code>T prev = x.fetch_add(v);</code></p>
<p>С помощь этой операции (на самом деле достаточно просто атомарного инкремента) и двух атомиков можно реализовать честный протокол взаимного исключения для произвольного числа потоков - ticket spinlock.</p>
<p>Идея такая же, как и в алгоритме Лампорта: потоки, которые хотят войти в критическую секцию, выстраиваются в очередь и ждут, пока потоки впереди них посетят критическую секцию. Но в отличие от алгоритма Лампорта, где потоки сами общались между собой и выбирали себе номерки, в ticket спинлоке используется &quot;автомат&quot; для выдачи последовательных номерков - атомарная переменная с RMW-операций <code>fetch-and-add</code> - который гарантирует уникальность и монотонность выдаваемых номерков.</p>
<p>Алгоритм гарантирует честность, doorway-секцией для ticket спинлока является всего одна строчка - выдача номерка (<code>next_free_ticket.fetch_add(1)</code>).</p>
<p>Для того, чтобы понять, что пришла его очередь, каждый поток смотрит на специальное табло - на счетчик <code>owner_ticket</code>, в котором записан номерок, обладателю которого разрешается зайти в критическую секцию. Значение этого счетчика увеличивает поток, который покидает критическую секцию, тем самым вызывая поток, который следует за ним в виртуальной очереди.</p>
<p>Псевдокод:</p>
<pre><code>def init():
    next-ticket = 0
    owner-ticket = 0

def lock():
    ticket = fetch-and-add(next-ticket, 1)
    while ticket != owner-ticket:
        pass

def unlock():
    owner-ticket = owner-ticket + 1</code></pre>
<p>На атомиках:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> ticket_spinlock {
<span class="kw">private</span>:
    <span class="kw">using</span> ticket = <span class="bu">std::</span>size_t;
<span class="kw">public</span>:
    ticket_spinlock()
        : owner_ticket(<span class="dv">0</span>)
        , next_free_ticket(<span class="dv">0</span>)
    {}

    <span class="dt">void</span> lock() {
        ticket this_thread_ticket = next_free_ticket.fetch_add(<span class="dv">1</span>);
        <span class="cf">while</span> (owner_ticket.load() != this_thread_ticket) {
            <span class="co">// wait</span>
        }
    }

    <span class="dt">void</span> unlock() {
        owner_ticket.store(owner_ticket.load() + <span class="dv">1</span>);
    }
<span class="kw">private</span>:
    <span class="bu">std::</span>atomic&lt;<span class="dt">ticket_t</span>&gt; owner_ticket;
    <span class="bu">std::</span>atomic&lt;<span class="dt">ticket_t</span>&gt; next_free_ticket;
};</code></pre></div>
<p>Заметим, что в <code>unlock</code> инкремент тикета не обязан быть атомарным, т.к. в этом месте не бывает конкуренции между потоками, достаточно сделать <code>owner_ticket.store(owner_ticket.load() + 1)</code></p>
<p>Также заметим, что монотонность номерков в алгоритме не требуется.</p>
</body>
</html>
