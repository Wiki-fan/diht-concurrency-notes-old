# Примитивы синхронизации: условные переменные, семафоры, фьютексы

## Мотивация: какую задачу мы хотим решать?
Мы хотим строить очереди. Есть два класса потока: producer / consumer. Одни кладут данные, другие берут. Мьютексы, очевидно, эту задач не решают.  
Интерфейс: `enq`, `deq`. Отличие в том, что методы блокирующие. Они должны завершиться корректно. Если сейчас места
в очереди нет, а надо положить, или извлекаем из пустой, то ждем, пока можно будет правильно выполнить метод.  
Очереди в параллельном мире полезны тем, что уравновешивают потоки, работающие с разной скоростью.
С их помощью можно реализовать thread pool.  

В случае thread pool очередь балансирует нагрузку. Если в очереди есть задачи, то все потоки заняты, если она пуста,
значит, задач нет.  
Итак, хотим соорудить такую очередь. Как ждать, пока элемент не будет добавлен? Наоборот, как ждать, пока очередь не освободиться?  

## Условные переменные
Это еще один механизм синхронизации. Три метода, решающие три задачи:

1. ожидание выполнения какого-то события;
2. оповестить один спящий поток;
3. разбудить все спящие потоки.

Это как раз то, что нам нужно: `cv.wait(mtx)` - заснуть в ожидание потока, отпустив мьютекс. С условной переменной всегда работает два потока.

На примере очереди, есть контейнер, мьютекс, предикат _очередь не пуста_ и условная переменная.

### Интерфейс
Поток выполняет `wait(mtx)`, когда он владеет мьютексом `mtx`. Поток атомарно отпускает мьютекс и засыпает в ожидании сигнала (методы 2 и 3). Когда сигнал приходит, мьютекс вновь захватывается. Атомарнось важна, потому что иначе другой поток может взять мьютекс, послать сигнал, и только затем наш поток заснет. Но так он пропустит сигнал.

`notify` не блокируется другими потоками. Если сигнал никто не ждал, то он просто потеряется. Ну и ладно. Если же сигнал пришел не тому потоку, у которого был `wait`, то тоже. Это уже грустно.

Когда поток просыпается, он получает мьютекс обратно. Это значит, что он встает в очередь на захват мьютекса. И когда он его получит, еще неизвестно.

***

Условная переменная связана с предикатом. На уровне кода, однако, синтаксически, между очередью, условной переменной, контейнером и т. п. никакой связи нет.

## Реализация очереди

### Очередь неограниченного размера

Тонкость в том, что `wait` может вернуть управление: ложное пробуждение (spurious wakeup). Условие может остаться ложным. Но есть еще intercepted (stolen) wakeup: другой поток перехватывает сигнал, предназначенный для другого потока (смотрим слайд).

Вывод: условие проверяем в цикле. Сигнал означает лишь что надо проверить, стало ли верным условие. В языке C++ есть сигнатура `cv.wait(mtx, pred)`. Она скрывает эту проблему, и цикл можно не писать.

А как же правильно сигналить при добавлении элемента? Может, не нужно сигналить, если добавляем элемент в непустую очередь?

_Доказательство корректности_. Ясно, что благодаря мьютексам можно свести задачу к последовательной. Рисуем пути Дика (только если `deq` при нуле элементов, стрелку ставим пунктиром вниз, а точку просто вправо). В каждый момент времени есть два типа `deq`. Одни еще не были вызваны, другие спали. Они не отличаются... ничем! Так что при сигнализировании можно как бы считать, что они перемещаются в очереди. Пусть у нас есть `k` элементов, а мы делаем `k + 1`-й `enq`.

Итак, всегда делаем `notify_all`. Почему это работает? При переносе спящих в будущее у нас корректная скобочная последовательность, а `|enq| - |deq| = k + 1`? Индукция по `k`.

Основные идеи: переносим пунктирные стрелки влево, используем предположение индукции и неравенство на общее количество вызовов `|deq| >= |enq|`.

Работает `notify_all`.  
Работает также и `notify_one`.  
Даже `if item.size() = 1 then notify_all` работает.  
Но не работает `if item.size() = 1 then notify_one` - нет! (Сценарий на слайде).

### Очередь ограниченного размера

Очевидный ход: завести еще одну условную переменную. В домашке напишем и все увидим.

## Фьютексы

Напишем условную переменную сейчас примерно так, как есть в Linux. Для этого понадобится _фьютекс_.

Заметим, что условные переменные и мьютексы по сути похожи своим паттерном работы, не смотря на разные механизмы и разные исполняемые задачи.

Фьютекс (fast usercpace mutex) - это очередь потоке в ядре, связанные неким образом с ячейкой.

Интерфейс:

1. `futex-wait(addr, value)`: если `addr != value`, засыпить поток;
2. `futex-wake(addr)`: разбудить поток, связанный с ячейкой `addr`.

Семантика значения в ячейке `addr` фьютексу неизвестна.

Эти операции в ядре исполнаяются спинлоком, так что между проверкой значения в `addr` и остановкой потока нельзя сделать `futex-wait` (типа они блокируются).

Итак, мы хотим написать нормальный мьютекс, то есть мьютекс с Fast Path. Если есть конкуренция (по-научному contention) мы хотим остановиться на время ожидания. А если ее нет, то мы хотим захват сделать быстро, щелкнув атомиком. Так можно избежать прохода в ядро, а это быстрее.

### Реализация мьютекса

У нас будет счетчик конкурирующих потоков. Если поток увеличивает счетчик с нуля до одного, то он сразу проходит. А если нет, то надо поспать. (См. слайды.)

### Реализация условной переменной

Немного сложнее. Считаем число отправленных сигналов. Проблема  втом, что нужна атомарность в разблокировки мьютекса. В реализации `wait` на слайде мы засыпаем только если после анлока счетчик не изменился. Иначе у нас будет упущенный сигнал!

***

Но вообще все это детские шалости. Надо читать статью _Futexes are Tricky_, где описано, как в Linux мастерили быстрые мьютексы.

## Семафоры

> Это лажа. (Р. Липовский)

Семафор - это блокирующий счетчик и очередь потоков. Многие вещи можно написать и с их помощью.

Интерфейс:

1. уменьшить счетчик, если это возможно, или заснуть иначе;
2. увеличить счетчик.

Значения счетчика получить нельзя. Это и ненужно.

Названий методов очень много. Оригинальные `P` и `V` придуманы автором - Дейкстрой.

Семафор можно написать на условных переменных. Эту задачу нужно в совершенстве решать на зачете.
