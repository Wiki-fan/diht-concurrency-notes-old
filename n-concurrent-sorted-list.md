## Постановка задачи
Хотим написать многопоточный односвязный сортированный список. Его можно использовать, например, в качестве бакета хэш-таблицы. Позже мы улучшим его асимптотику до $O(\log n)$, и получится многопоточный ассоциативный контейнер (а сбалансированные деревья, которые обычно используются для этого, не параллелятся).
Сортированным список будет потому, что можно легко узнать, какие именно узлы будет затрагивать `Insert` и `Remove`. 

## Реализация
Для устранения краевых эффектов вставим по краям вершины-сентинелы: $-\infty$ в начало и $+\infty$ в конец.
В каждом узле будем хранить спинлок, чтобы блокировки были мелкогранулярными.

Рис. Конкурирование удаления со вставкой, Конкурирование удаления с удалением

Поэтому для удаления нужно блокировать две вершины: удаляемую и вершину перед ней. Для вставки достаточно блокировать одну, но для упрощения теоретических рассуждений будем считать, что тоже блокируем две.

Блокировать вершины будем последовательно: в порядке их нахождения в списке. 

Утв. Если заблокировались на вершине, то её не удалят из списка.
Д-во: Это так, ибо чтобы удалить вершину, нужно её заблокировать самому.

Хотим написать итератор.
Инвариант:
1. Держим лок узла
1. Достижимы из head

База: для $-\infty$ соблюдается.
Переход: картинка.
Перейдём к следующей вершине так: 
```
lock B
free A
```
A было заблокировано, поэтому B не удалят, и мы можем перейти по валидной A.next.

Если так дошли до узла, в котором $<x$, а в следующем $\ge x$, то блокируем и возвращаем.

Эта тактика называется hand-over-hand locking --- лок как бы передаётся из рук в руки.

Голодания нет: итератор, идущий сзади, не обгонит итератор, идущий спереди. У итератора конечное число операций, значит он рано или поздно завершится, и идущие сзади смогут пройти через то место, где он стоял.

Но это проблема: если идущий первым итератор вытеснен планировщиком, то за ним образуется пробка. К тому же, мы берём слишком много локов, и это медленно.

Такая тактика называется "пессимистичными блокировками" (Pessimistic Locking): мы постоянно считаем, что другие потоки могут нам помешать, и поэтому явно страхуемся от всевозможных конкурирующих операций.

## Optimistic Locking

Мы идём вперёд без блокировок, не беспокоясь, что нас удалят.

```
Locate(x):
	pred = head
	curr = head->next
	while (curr->key < x)
		pred = curr
		curr = curr->next
	return (pred, curr)
```
Возможны конфликты: рис. 1, 2, 3

## Как реализовать удаление вершин?
1. Сборка мусора
Shared Pointers не помогают, даже если у них атомарные счётчики.
Можно написать свой сборщик мусора для C++.
2. Однопроходной Arena Allocator, который при инициализации выделяет арену (буфер) большого размера и при каждой аллокации нового узла откусывает от этой арены маленький кусочек. Выделенная память не освобождается и не переиспользуется до самой смерти аллокатора.

  При использовании такого аллокатора потокам не нужно явно освобождать память отдельных узлов, вся выделенная память будет освобождена разом при разрушении аллокатора.
  
## Как выполнять валидацию?
Блокируем пару. Запускаем поиск из head. Если поиск достиг pred, то значит, что ничего не поменялось. При этом, так как вершины залочены, их никто не удалит. Но при этом могут сломать нам поиск, выполнив с ним вставку или удаление.

С учётом цепочек из удалённых вершин список превращается в орграф. 

Утв. Вне зависимости от порядка добавления и удаления, монотонность не нарушается.
Д-во: Монотонность может нарушиться только в процессе мутации --- вставки или удаления. Рассматриваем пошагово эти действия и видим, что монотонность не нарушается.

Утв. Каждая модификация не нарушает достижимости $+\infty$. 
Д-во: Если в процессе повторного поиска нас выкинули в branch из основного списка master, то мы вернёмся обратно в master, так как рёбра мы не удаляем. При этом то ребро, которое мы ищем, не удалят, так как оно залочено.

Можно избавитсья от повторного сканирования: перед удалением узла красим его в чёрный цвет. То есть удаление выглядит так: покраска, перестроение ссылок и (позже) освобождение памяти.

Заметим, что валидацию можно свести к проверке, что prev->next == cur, и что они обе белые. Но почему это всё корректно?

Инвариант: все белые вершины лежат на master-цепи.
Д-во: индукция по количеству действий.
База: Изначально весь список белый.
Шаг: Insert вставляет одну белую вершину --- инвариант сохраняется.
Delete: рис. Почему delete не может перебросить указатель next на чёрную вершину?

Утв. Перед чёрной вершиной не может быть белых.
Д-во: Действительно, такое может быть только при удалении, но удаление происходит под локами.

Следствие. Если вершина белая, то она в master.

Поэтому для Contains нужно лишь проверить белость вершины. Так мы избавляемся от перезапуска Locate при Contains.

2005 г. Wait-Free Search.
Пусть мы ищем x, которого нет в списке. Пусть в данный момент мы стоим на вершине (x-1), наш next указывает на (x+1). Пусть потом нас удалили, а вершину x вставили. Узнать о том, что вершина появилась в списке, мы можем лишь при помощи перезапуска. Но формально доказано, что в таких случаях можно возвращать false, и поток, вызвавший Contains, не заметит подвоха: для него это будет неразличимо.

